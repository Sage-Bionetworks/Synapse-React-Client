{"version":3,"file":"sqlFunctions.9bad0aa7.js","sources":["../../src/lib/utils/functions/sqlFunctions.ts"],"sourcesContent":["import { lexer, parser } from 'sql-parser'\nimport { SelectColumn, Row } from '../synapseTypes'\nimport { SYNAPSE_ENTITY_ID_REGEX } from '../functions/RegularExpressions'\n\nexport type KeyValue = {\n  [index: string]: string\n}\n\nexport type SQLOperator = 'LIKE' | '=' | 'HAS'\n\n// look for \"group by\", multi-line and case insensitive\nconst GROUP_BY_REGEX = /group by/im\nexport const isGroupByInSql = (sql: string): boolean => {\n  return GROUP_BY_REGEX.test(sql)\n}\nconst WITHOUT_SYN_PREFIX = 3\n\nconst generateTokenUsingOperator = (\n  literal: string,\n  operator: SQLOperator,\n  match: string,\n) => {\n  let usedMatchForLike = match\n  if (match.match(SYNAPSE_ENTITY_ID_REGEX)) {\n    // If we use a LIKE statement with a synId the backend will look for a string with the first three\n    // characters being 'syn', however, it stores synIds without 'syn', so the query will fail\n    // The backend usually parses 'syn' out, but not with the LIKE clause since its expecting a regex, so we\n    // parse this out. This will cause a bug if something matches the synId regex but is in free text.\n    usedMatchForLike = match.substring(WITHOUT_SYN_PREFIX)\n  }\n  // form the has clause, e.g sql = \".... HAS ('condition1', 'condition2',...,'conditionN')\n  const matchForHas = match\n    .split(',')\n    // NOTE - Using single quotes to surround the search term is necessary for the backend parser.\n    .map(el => `'${el}'`)\n    .join(',')\n  switch (operator) {\n    case 'LIKE':\n      return [\n        ['LITERAL', literal, '1'],\n        ['OPERATOR', operator, '1'],\n        ['STRING', `%${usedMatchForLike}%`, '1'],\n      ]\n    case 'HAS':\n      return [\n        ['LITERAL', literal, '1'],\n        ['OPERATOR', operator, '1'],\n        /* \n          Using PARAMETER as hack, the parser will use the exact value for a PARAMETER value,\n          it won't add quotes around the argument or remove parens (which is the standard behavior\n          for type STRING) that would cause an error on the backend\n        */\n        ['PARAMETER', `(${matchForHas})`, '1'],\n      ]\n    default:\n      // default use operator as-is\n      return [\n        ['LITERAL', literal, '1'],\n        ['OPERATOR', operator, '1'],\n        ['STRING', match, '1'],\n      ]\n  }\n}\n\nexport const getWhereInsertIndex = (tokens: string[][]): number => {\n  const existingWhereIndex = tokens.findIndex(el => el[0] === 'WHERE')\n  if (existingWhereIndex !== -1) {\n    return existingWhereIndex\n  }\n  let targetIndex = tokens.findIndex(el => el[0] === 'GROUP')\n  if (targetIndex !== -1) {\n    return targetIndex\n  }\n  targetIndex = tokens.findIndex(el => el[0] === 'HAVING')\n  if (targetIndex !== -1) {\n    return targetIndex\n  }\n  targetIndex = tokens.findIndex(el => el[0] === 'ORDER')\n  if (targetIndex !== -1) {\n    return targetIndex\n  }\n  //else insert it at the end\n  targetIndex = tokens.findIndex(el => el[0] === 'EOF')\n  return targetIndex\n}\n\n/**\n * This will construct a sql query by adding the conditions in searchParams\n * to the WHERE clause, preserving all other clauses.\n * If the searchParams are not defined, this will simply return the given sql.\n */\nexport const insertConditionsFromSearchParams = (\n  sql: string,\n  searchParams?: KeyValue,\n  operator: SQLOperator = 'LIKE',\n) => {\n  // TODO: Replace SQL manipulation with QueryFilters. See PORTALS-2157\n  // if there are no search params, or if all search params are QueryWrapper queries\n  if (!searchParams) {\n    return sql\n  }\n  const isQueryWrapperKey = (key: string) => key.startsWith('QueryWrapper')\n  const searchParamKeys = Object.keys(searchParams)\n  if (\n    searchParamKeys.length === 0 ||\n    searchParamKeys.every(isQueryWrapperKey)\n  ) {\n    return sql\n  }\n  const tokens: string[][] = lexer.tokenize(sql)\n  // we want to either create a where clause or insert into the where clause\n  const foundIndex = tokens.findIndex(el => el[0] === 'WHERE')\n  const whereClauseIndex = getWhereInsertIndex(tokens)\n  const indexAfterWhereClause = whereClauseIndex + 1\n  if (foundIndex === -1) {\n    // insert a where clause\n    tokens.splice(whereClauseIndex, 0, ['WHERE', 'WHERE', '1'])\n  } else {\n    // if this is inserting into a where clause then we have to make sure that the logic is chained\n    tokens.splice(indexAfterWhereClause, 0, ['CONDITIONAL', 'AND', '1'])\n  }\n  const searchParamsLen = Object.keys(searchParams).length\n  Object.keys(searchParams).forEach((key, index) => {\n    const token = generateTokenUsingOperator(key, operator, searchParams[key])\n    if (index < searchParamsLen - 1) {\n      // make sure to chain the ANDs until the last one\n      token.unshift(['CONDITIONAL', 'AND', '1'])\n    }\n    tokens.splice(indexAfterWhereClause, 0, ...token)\n  })\n  return formatSQLFromParser(tokens)\n}\n\nexport const formatSQLFromParser = (tokens: string[][]) => {\n  // replace all DBLSTRINGs (escaped strings) with LITERALs\n  tokens.forEach(value => {\n    if (value[0] === 'DBLSTRING') {\n      value[0] = 'LITERAL'\n    }\n  })\n  // if synId has a DOT (e.g. 'syn123.2') then we have to alter the sql produced\n  const dotIndex = tokens.findIndex(val => val[0] === 'DOT')\n  if (dotIndex !== -1) {\n    // Given sql with a versioned entity, e.g. \"select * from syn123.2\"\n    // Tokens has the form:\n    /*\n    [\n      [\"SELECT\" , \"select\"],\n      ..\n      [\"FROM\", \"from\"],\n      [\"LITERAL\", \"syn123\"],\n      [\"DOT\", \".\"],\n      [\"LITERAL\", \"2\"],\n\n      which we need to transform to\n\n      [\"SELECT\" , \"select\"],\n      ..\n      [\"FROM\", \"from\"],\n      [\"LITERAL\", \"syn123.2\"],\n    */\n\n    const synId = tokens[dotIndex - 1][1]\n    const version = tokens[dotIndex + 1][1]\n    const synIdWithVersion = `${synId}.${version}`\n    tokens.splice(dotIndex, 2)\n    tokens[dotIndex - 1] = ['LITERAL', synIdWithVersion]\n  }\n  const newSql = parser.parse(tokens).toString() as string\n  // construct the sql using their formatter and then alter it to remove erroneous\n  // backticks from the table identifier: e.g. (their output) `syn1234` ->  (our output) syn1234\n  const synId = tokens[tokens.findIndex(el => el[0] === 'FROM') + 1][1]\n  const synIdWithBackticks = `\\`${synId}\\``\n  return newSql.replace(synIdWithBackticks, synId)\n}\n\n//parses synapse entity id from a sql query string\n//look for a pattern of 'from[some number of spaces]syn[somenumbers]` case insensitive\nexport const parseEntityIdFromSqlStatement = (sql: string): string => {\n  const matches = sql.match(/(from)\\s+(syn)\\d+/gi)\n  return matches && matches[0] ? matches[0].substr(5).trim() : ''\n}\n\nexport const parseEntityIdAndVersionFromSqlStatement = (\n  sql: string,\n): { entityId: string; versionNumber?: number } | null => {\n  const regex = /from\\s+(syn\\d+)(?:\\.(\\d+))?/i\n  const matches = regex.exec(sql)\n  if (!matches) {\n    return null\n  }\n  return {\n    entityId: matches[1],\n    versionNumber: matches[2] ? parseInt(matches[2]) : undefined,\n  }\n}\n\nexport const resultToJson = <T>(\n  headerColumns: SelectColumn[],\n  rowColumns: Row[],\n): T[] => {\n  const result: T[] = []\n  const rows = rowColumns.map(row => row.values)\n  const headers = headerColumns.map(column => column.name)\n  rows.forEach((row, index) => {\n    result[index] = {} as T\n    row.forEach((text, cellIndex) => {\n      result[index][headers[cellIndex]] = text\n    })\n  })\n  return result\n}\n"],"names":[],"mappings":"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"}