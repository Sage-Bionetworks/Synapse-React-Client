{"version":3,"file":"useGetInfoFromIds.fd3ee364.js","sources":["../../src/lib/utils/hooks/useGetInfoFromIds.ts"],"sourcesContent":["import { chunk, uniq, without } from 'lodash-es'\nimport { useState } from 'react'\nimport useDeepCompareEffect from 'use-deep-compare-effect'\nimport { SynapseConstants } from '..'\nimport { getEntityHeaders, getGroupHeadersBatch } from '../SynapseClient'\nimport { useSynapseContext } from '../SynapseContext'\nimport {\n  EntityHeader,\n  Reference,\n  ReferenceList,\n  UserGroupHeader,\n} from '../synapseTypes'\n\nexport type HookType = 'ENTITY_HEADER' | 'USER_PROFILE'\nexport type UseGetInfoFromIdsProps = {\n  ids: string[]\n  type: HookType\n}\n\ntype LookupRequestType = string | Reference\n\nconst UserGroupHeaderTemplate: UserGroupHeader = {\n  ownerId: '', // A foreign key to the ID of the 'principal' object for the user\n  firstName: 'Unknown', // This person's given name (forename)\n  lastName: 'Unknown', // This person's family name (surname)\n  userName: 'Unknown', // A name chosen by the user that uniquely identifies them\n  isIndividual: false,\n}\n\nconst entityHeaderTemplate: EntityHeader = {\n  name: 'Unknown', //\tThe name of the entity\n  id: 'unknown', //\tThe id of the entity\n  type: 'org.sagebionetworks.repo.model.FileEntity', //\tThe type of the entity\n  versionNumber: 0, //\tThe version number of the entity\n  versionLabel: 'placeholder', //\tThe user defined version label of the entity\n  benefactorId: 0, //\tThe ID of the entity that this Entity's ACL is inherited from.\n  createdOn: 'null', //\tThe date this entity was created.\n  modifiedOn: 'null', //\tThe date this entity was last modified.\n  createdBy: 'null', //\tThe ID of the user that created this entity.\n  modifiedBy: 'null', //\tThe ID of the user that last modified this entity.\n}\n\nconst getEntityHeaderItems = async (\n  lookupList: ReferenceList,\n  token: string | undefined,\n): Promise<EntityHeader[]> => {\n  const newData = await getEntityHeaders(lookupList, token)\n  const notFound = lookupList.filter(\n    item => newData.results.map(item => item.id).indexOf(item.targetId) === -1,\n  )\n  const notFoundPlaceholders = notFound.map(item => ({\n    ...entityHeaderTemplate,\n    id: item.targetId,\n    name: `${item.targetId}`,\n  }))\n\n  return [...newData.results, ...notFoundPlaceholders]\n}\n\nconst getUserGroupHeaderItems = async (\n  lookupList: string[],\n): Promise<UserGroupHeader[]> => {\n  const newData = (await getGroupHeadersBatch(lookupList)).children\n  const notFound = lookupList.filter(\n    item => newData.map(item => item.ownerId).indexOf(item) === -1,\n  )\n  const notFoundPlaceholders = notFound.map(item => ({\n    ...UserGroupHeaderTemplate,\n    ownerId: item,\n    name: `Unknown User (${item})`,\n  }))\n\n  return [...newData, ...notFoundPlaceholders]\n}\n\n/**\n * React hook to get user profiles or entities. Utilizes a custom cache in sessionStorage.\n *\n * For fetching just one entity or usergroup, see useGetEntity/useGetUserGroupHeader hooks powered by react-query\n * @returns\n */\nexport default function useGetInfoFromIds<\n  T extends EntityHeader | UserGroupHeader,\n>(props: UseGetInfoFromIdsProps): T[] {\n  const { ids, type } = props\n  const { accessToken } = useSynapseContext()\n\n  const [data, setData] = useState<Array<T>>([])\n\n  const idProp = (type: HookType) =>\n    type === 'USER_PROFILE' ? 'ownerId' : 'id'\n\n  const storageKey = (type: HookType) =>\n    type === 'USER_PROFILE'\n      ? SynapseConstants.USER_PROFILE_STORAGE_KEY\n      : SynapseConstants.ENTITY_HEADER_STORAGE_KEY\n\n  // look at current list of data, see if incoming ids has new data,\n  // if so grab those ids\n  const curList = data.map(el => el[idProp(type)])\n  const incomingList = ids.filter(el => el !== SynapseConstants.VALUE_NOT_SET)\n  const newValues = uniq(without(incomingList, ...curList))\n\n  const saveToSessionStorage = (data: T[], type: HookType) => {\n    if (!data.length) {\n      return\n    }\n    //get what's there\n    const dataInStorage = sessionStorage.getItem(storageKey(type))\n    try {\n      const dataInStorageAsObjectArr: T[] = dataInStorage\n        ? JSON.parse(dataInStorage)\n        : []\n      //get an array of ids for items already in storage\n      const ids = dataInStorageAsObjectArr.map(item => item[idProp(type)])\n      //push all the new data if ids are new\n      for (const dataObject of data) {\n        if (!ids.includes(dataObject[idProp(type)])) {\n          dataInStorageAsObjectArr.push(dataObject)\n        }\n      }\n      sessionStorage.setItem(\n        storageKey(type),\n        JSON.stringify(dataInStorageAsObjectArr),\n      )\n    } catch (e) {\n      sessionStorage.setItem(storageKey(type), JSON.stringify(data))\n    }\n  }\n\n  // Alina TODO: check if the items are already in Local Storage before making server call.\n\n  // Michael TODO: There's a bug where the data held in useGetInfoFromIds will be stale if the user token changes,\n  // this can be solved by using the useCompare hook on the token to track when it changes\n  useDeepCompareEffect(() => {\n    let isCancelled = false\n    const getData = async () => {\n      if (newValues.length > 0) {\n        try {\n          const newIds = Array.from<string>(newValues)\n          const newReferences: LookupRequestType[] =\n            type === 'USER_PROFILE'\n              ? newIds\n              : newIds.map(el => ({ targetId: el }))\n          const newReferencesChunks = chunk(newReferences, 45)\n          const totalData: T[] = []\n          for (const newReferences of newReferencesChunks) {\n            const newData =\n              type === 'USER_PROFILE'\n                ? await getUserGroupHeaderItems(newReferences as string[])\n                : await getEntityHeaderItems(\n                    newReferences as ReferenceList,\n                    accessToken,\n                  )\n            totalData.push(...(newData as T[]))\n          }\n          if (!isCancelled) {\n            setData(oldData => oldData.concat(...(totalData as T[])))\n          }\n        } catch (error) {\n          console.error('Error on data retrieval', error)\n        }\n      }\n      saveToSessionStorage(data, type)\n    }\n    getData()\n    return () => {\n      isCancelled = true\n    }\n  }, [accessToken, type, newValues])\n  return data\n}\n"],"names":["SynapseConstants.USER_PROFILE_STORAGE_KEY","SynapseConstants.ENTITY_HEADER_STORAGE_KEY","SynapseConstants.VALUE_NOT_SET"],"mappings":"0QACA,KAAA,GAAA,OAAA,MAAA,SAoBM,EAA2C,CAC/C,QAAS,GACT,UAAW,UACX,SAAU,UACV,SAAU,UACV,aAAc,EAChB,EAEM,EAAqC,CACzC,KAAM,UACN,GAAI,UACJ,KAAM,4CACN,cAAe,EACf,aAAc,cACd,aAAc,EACd,UAAW,OACX,WAAY,OACZ,UAAW,OACX,WAAY,MACd,EAEM,EAAuB,MAC3B,EACA,IAC4B,CAC5B,KAAM,GAAU,KAAM,GAAiB,EAAY,CAAK,EAIlD,EAAuB,AAHZ,EAAW,OAC1B,AAAA,GAAQ,EAAQ,QAAQ,IAAI,AAAQ,GAAA,EAAK,EAAE,EAAE,QAAQ,EAAK,QAAQ,IAAM,EAC1E,EACsC,IAAI,AAAS,GAAA,EACjD,GAAG,EACH,GAAI,EAAK,SACT,KAAM,GAAG,EAAK,UACd,EAAA,EAEF,MAAO,CAAC,GAAG,EAAQ,QAAS,GAAG,CAAoB,CACrD,EAEM,EAA0B,KAC9B,IAC+B,CAC/B,KAAM,GAAW,MAAM,GAAqB,CAAU,GAAG,SAInD,EAAuB,AAHZ,EAAW,OAC1B,AAAA,GAAQ,EAAQ,IAAI,AAAQ,GAAA,EAAK,OAAO,EAAE,QAAQ,CAAI,IAAM,EAC9D,EACsC,IAAI,AAAS,GAAA,EACjD,GAAG,EACH,QAAS,EACT,KAAM,iBAAiB,IACvB,EAAA,EAEF,MAAO,CAAC,GAAG,EAAS,GAAG,CAAoB,CAC7C,EAQA,WAEE,EAAoC,CAC9B,KAAA,CAAE,MAAK,QAAS,EAChB,CAAE,eAAgB,IAElB,CAAC,EAAM,GAAW,EAAmB,CAAE,CAAA,EAEvC,EAAS,AAAC,GACd,IAAS,eAAiB,UAAY,KAElC,EAAa,AAAC,GAClB,IAAS,eACLA,EACAC,EAIA,EAAU,EAAK,IAAI,GAAM,EAAG,EAAO,CAAI,EAAE,EACzC,EAAe,EAAI,OAAO,AAAM,GAAA,IAAOC,CAA8B,EACrE,EAAY,EAAK,EAAQ,EAAc,GAAG,CAAO,CAAC,EAElD,EAAuB,CAAC,EAAW,IAAmB,CACtD,GAAA,CAAC,EAAK,OACR,OAGF,KAAM,GAAgB,eAAe,QAAQ,EAAW,CAAI,CAAC,EACzD,GAAA,CACF,KAAM,GAAgC,EAClC,KAAK,MAAM,CAAa,EACxB,GAEE,EAAM,EAAyB,IAAI,GAAQ,EAAK,EAAO,CAAI,EAAE,EAEnE,SAAW,KAAc,GACvB,AAAK,EAAI,SAAS,EAAW,EAAO,CAAI,EAAE,GACxC,EAAyB,KAAK,CAAU,EAG5C,eAAe,QACb,EAAW,CAAI,EACf,KAAK,UAAU,CAAwB,CACzC,QAEA,eAAe,QAAQ,EAAW,CAAI,EAAG,KAAK,UAAU,CAAI,CAAC,CAC/D,CAAA,EAOF,SAAqB,IAAM,CACzB,GAAI,GAAc,GA8BV,MA7BQ,UAAY,CACtB,GAAA,EAAU,OAAS,EACjB,GAAA,CACI,KAAA,GAAS,MAAM,KAAa,CAAS,EACrC,EACJ,IAAS,eACL,EACA,EAAO,IAAI,AAAO,GAAA,EAAE,SAAU,CAAA,EAAK,EACnC,EAAsB,EAAM,EAAe,EAAE,EAC7C,EAAiB,CAAA,EACvB,SAAW,KAAiB,GAAqB,CACzC,KAAA,GACJ,IAAS,eACL,KAAM,GAAwB,CAAyB,EACvD,KAAM,GACJ,EACA,CACF,EACI,EAAA,KAAK,GAAI,CAAe,CACpC,CACA,AAAK,GACH,EAAQ,AAAW,GAAA,EAAQ,OAAO,GAAI,CAAiB,CAAC,QAEnD,GACC,QAAA,MAAM,0BAA2B,CAAK,CAChD,CAEF,EAAqB,EAAM,CAAI,CAAA,KAG1B,IAAM,CACG,EAAA,EAAA,CAEf,EAAA,CAAC,EAAa,EAAM,CAAS,CAAC,EAC1B,CACT"}