{"version":3,"file":"MarkdownSynapse.079d4808.js","sources":["../../src/lib/containers/widgets/Bookmarks.tsx","../../src/lib/containers/widgets/SynapseImage.tsx","../../src/lib/containers/widgets/SynapsePlot.tsx","../../src/lib/utils/hooks/SynapseAPI/useGetApprovedSubmissionInfo.ts","../../src/lib/containers/IDUReportSubmissionInfo.tsx","../../src/lib/containers/IDUReport.tsx","../../src/lib/containers/MarkdownSynapse.tsx"],"sourcesContent":["import * as React from 'react'\n\ntype BookmarksProps = {\n  footnotes: string\n}\n\nclass Bookmarks extends React.Component<BookmarksProps, {}> {\n  constructor(props: BookmarksProps) {\n    super(props)\n    this.renderBookmarks = this.renderBookmarks.bind(this)\n  }\n\n  /**\n   * Returns bookmarks\n   *\n   * @returns JSX for the embedded bookmarks in the markdown passed in as a prop\n   * @memberof Bookmarks\n   */\n  public renderBookmarks() {\n    const copyFootnotes: string = String(this.props.footnotes)\n\n    // find all the links embedded in the markdown below\n    const regex = /Synapse widget&gt;<\\/span>(.*)</g\n    let matchedGroup: RegExpExecArray | null\n    const output = []\n    // below we use regex.exec to find the find matched group containing the citation source\n    while ((matchedGroup = regex.exec(copyFootnotes))) {\n      output.push(matchedGroup[1])\n    }\n\n    // return all the links formatted accordingly\n    return output.map((el, index) => {\n      const isBeforeLastElement = index < output.length - 1\n      return (\n        <React.Fragment key={index}>\n          <button className=\"SRC-markdown-bookmark\" id={`bookmark${index}`}>\n            [{index + 1}]\n          </button>\n          <span dangerouslySetInnerHTML={{ __html: el }} />\n          {isBeforeLastElement && <br />}\n        </React.Fragment>\n      )\n    })\n  }\n\n  public render() {\n    return (\n      <React.Fragment>\n        <hr />\n        {this.renderBookmarks()}\n      </React.Fragment>\n    )\n  }\n}\n\nexport default Bookmarks\n","import * as React from 'react'\nimport { getEntity, getFiles } from '../../utils/SynapseClient'\nimport { SynapseContext } from '../../utils/SynapseContext'\nimport {\n  BatchFileRequest,\n  BatchFileResult,\n  FileEntity,\n  FileHandle,\n  FileHandleAssociateType,\n  FileHandleAssociation,\n} from '../../utils/synapseTypes/'\n\ntype SynapseImageProps = {\n  wikiId?: string\n  synapseId?: string\n  fileName?: string\n  fileResults?: FileHandle[]\n  params: {\n    align: string\n    scale: string\n    // this should be treated as a boolean, but the actual type that will come through\n    // is a string which I don't want to mis-represent\n    responsive: string\n    altText: string\n  }\n}\n\ntype SynapseImageState = {\n  preSignedURL: string\n}\n\nclass SynapseImage extends React.Component<\n  SynapseImageProps,\n  SynapseImageState\n> {\n  constructor(props: SynapseImageProps) {\n    super(props)\n    this.getEntity = this.getEntity.bind(this)\n    this.getSynapseFiles = this.getSynapseFiles.bind(this)\n    this.state = {\n      preSignedURL: '',\n    }\n  }\n\n  static contextType = SynapseContext\n\n  public getEntity() {\n    const { synapseId } = this.props\n    if (synapseId) {\n      getEntity<FileEntity>(this.context.accessToken, synapseId).then(\n        // https://rest-docs.synapse.org/rest/org/sagebionetworks/repo/model/FileEntity.html\n        (data: FileEntity) => {\n          const fileHandleAssociationList = [\n            {\n              associateObjectId: synapseId,\n              associateObjectType: FileHandleAssociateType.FileEntity,\n              fileHandleId: data.dataFileHandleId,\n            },\n          ]\n          this.getSynapseFiles(fileHandleAssociationList, data.dataFileHandleId)\n        },\n      )\n    }\n  }\n  public getSynapseFiles(\n    fileHandleAssociationList: FileHandleAssociation[],\n    id: string,\n  ) {\n    // overload the method for two different use cases, one where\n    // the image is attached to an entity and creates a list on the spot,\n    // the other where list is passed in from componentDidMount in MarkdownSynapse\n    const request: BatchFileRequest = {\n      includeFileHandles: false,\n      includePreSignedURLs: true,\n      includePreviewPreSignedURLs: false,\n      requestedFiles: fileHandleAssociationList,\n    }\n    getFiles(request, this.context.accessToken)\n      .then((data: BatchFileResult) => {\n        const { preSignedURL } = data.requestedFiles.filter(\n          el => el.fileHandleId === id,\n        )[0]\n        this.setState({\n          preSignedURL: preSignedURL!,\n        })\n      })\n      .catch(err => {\n        console.error('Error on getting image ', err)\n      })\n  }\n  public componentDidMount() {\n    if (!this.props.wikiId) {\n      // Get file handle as external attachment\n      this.getEntity()\n    } else {\n      // Can get presigned url right away from wiki association\n      const { fileName, fileResults = [] } = this.props\n      const { id } = fileResults.filter(el => el.fileName === fileName)[0]\n      const fileHandleAssociationList: FileHandleAssociation[] = [\n        {\n          associateObjectId: this.props.wikiId,\n          associateObjectType: FileHandleAssociateType.WikiAttachment,\n          fileHandleId: id,\n        },\n      ]\n      this.getSynapseFiles(fileHandleAssociationList, id)\n    }\n  }\n\n  public render() {\n    const { params } = this.props\n    const { align = '', altText = 'synapse image' } = params\n\n    let scale = 'auto'\n    if (params.scale && params.scale !== '100') {\n      scale = `${Number(params.scale)}%`\n    }\n\n    const alignLowerCase = align.toLowerCase()\n    let className = ''\n    if (alignLowerCase === 'left') {\n      className = 'floatLeft'\n    }\n    if (alignLowerCase === 'right') {\n      className = 'floatright'\n    }\n    if (alignLowerCase === 'center') {\n      className = 'align-center'\n    }\n    let style: React.CSSProperties = {\n      width: scale,\n      height: scale,\n    }\n    if (!this.state.preSignedURL) {\n      return null\n    }\n    return (\n      <React.Fragment>\n        <img\n          alt={altText}\n          className={'img-fluid  ' + className}\n          src={this.state.preSignedURL}\n          style={style}\n        />\n      </React.Fragment>\n    )\n  }\n}\nexport default SynapseImage\n","import Plotly from 'plotly.js-basic-dist'\nimport * as React from 'react'\nimport createPlotlyComponent from 'react-plotly.js/factory'\nimport { SynapseConstants } from '../../utils/'\nimport { getFullQueryTableResults } from '../../utils/SynapseClient'\nimport {\n  QueryResultBundle,\n  QueryBundleRequest,\n} from '../../utils/synapseTypes/'\nimport { parseEntityIdFromSqlStatement } from '../../utils/functions/sqlFunctions'\nimport { SynapseContext } from '../../utils/SynapseContext'\nconst Plot = createPlotlyComponent(Plotly)\n\nexport type SynapsePlotProps = {\n  ownerId?: string\n  wikiId?: string\n  widgetparamsMapped?: any\n}\n\ntype SynapsePlotState = {\n  isLoaded: boolean\n  queryData: QueryResultBundle\n}\n\nclass SynapsePlot extends React.Component<SynapsePlotProps, SynapsePlotState> {\n  constructor(props: SynapsePlotProps) {\n    super(props)\n    this.state = {\n      isLoaded: false,\n      queryData: {} as QueryResultBundle,\n    }\n    this.fetchPlotlyData = this.fetchPlotlyData.bind(this)\n    this.showPlot = this.showPlot.bind(this)\n  }\n\n  static contextType = SynapseContext\n\n  public componentDidMount() {\n    this.fetchPlotlyData()\n  }\n  /**\n   * Get data for plotly\n   *\n   * @returns data corresponding to plotly widget\n   */\n  public fetchPlotlyData() {\n    const { query } = this.props.widgetparamsMapped\n    const queryRequest: QueryBundleRequest = {\n      concreteType: 'org.sagebionetworks.repo.model.table.QueryBundleRequest',\n      partMask: SynapseConstants.BUNDLE_MASK_QUERY_RESULTS,\n      entityId: parseEntityIdFromSqlStatement(query),\n      query: {\n        sql: query,\n      },\n    }\n\n    getFullQueryTableResults(queryRequest, this.context.accessToken)\n      .then((data: QueryResultBundle) => {\n        this.setState({\n          isLoaded: true,\n          queryData: data,\n        })\n      })\n      .catch((err: any) => {\n        console.log('Error on full table query ', err)\n      })\n  }\n\n  public showPlot() {\n    if (!this.state.isLoaded) {\n      return\n    }\n    const { title, xtitle, ytitle, type, xaxistype, showlegend } =\n      this.props.widgetparamsMapped\n    const queryData = this.state\n    const isHorizontal = this.props.widgetparamsMapped.horizontal.toLowerCase()\n    const layout: any = {\n      showlegend,\n      title,\n    }\n    if (xtitle) {\n      layout.xaxis = {\n        title: xtitle,\n      }\n    }\n    if (xaxistype) {\n      layout.xaxis = {\n        ...layout.xaxis,\n        xaxistype: xaxistype.toLowerCase(),\n      }\n    }\n    if (ytitle) {\n      layout.yaxis = {\n        title: ytitle,\n      }\n    }\n    // init plot_data\n    const plotData: any = []\n    const orientation = isHorizontal ? 'v' : 'h'\n    const headers = queryData.queryData.queryResult.queryResults.headers\n    for (let i = 0; i < headers.length - 1; i += 1) {\n      // make an entry for each set of data points\n      plotData[i] = {\n        orientation,\n        name: headers[i + 1].name,\n        type: type.toLowerCase(),\n        x: [],\n        y: [],\n      }\n    }\n    // grab all the data\n    for (const row of queryData.queryData.queryResult.queryResults.rows) {\n      for (let j = 1; j < row.values.length; j += 1) {\n        // create pairs of data\n        const rowValues: any = row.values\n        plotData[j - 1].x.push(rowValues[0])\n        plotData[j - 1].y.push(rowValues[j])\n      }\n    }\n    return <Plot layout={layout} data={plotData} />\n  }\n\n  public render() {\n    if (!this.state.isLoaded) {\n      return null\n    }\n    return this.showPlot()\n  }\n}\nexport default SynapsePlot\n","import { useInfiniteQuery, UseInfiniteQueryOptions } from 'react-query'\nimport { SynapseClient } from '../..'\nimport { SynapseClientError } from '../../SynapseClientError'\nimport { useSynapseContext } from '../../SynapseContext'\nimport {\n  SubmissionInfoPage,\n  SubmissionInfoPageRequest,\n} from '../../synapseTypes/SubmissionInfo'\n\nexport function useGetApprovedSubmissionInfoInfinite(\n  accessRequirementId: string,\n  options?: UseInfiniteQueryOptions<\n    SubmissionInfoPage,\n    SynapseClientError,\n    SubmissionInfoPage\n  >,\n) {\n  const { accessToken } = useSynapseContext()\n  const request: SubmissionInfoPageRequest = {\n    accessRequirementId,\n  }\n  return useInfiniteQuery<SubmissionInfoPage, SynapseClientError>(\n    ['approvedSubmissionInfo', request],\n    async context => {\n      return await SynapseClient.getApprovedSubmissionInfo(\n        { ...request, nextPageToken: context.pageParam },\n        accessToken,\n      )\n    },\n    {\n      ...options,\n      getNextPageParam: page => page.nextPageToken,\n    },\n  )\n}\n","import React from 'react'\nimport { Skeleton } from '@material-ui/lab'\nimport { SubmissionInfo } from '../utils/synapseTypes/SubmissionInfo'\nimport { SMALL_USER_CARD } from '../utils/SynapseConstants'\nimport UserCard from './UserCard'\nimport { formatDate } from '../utils/functions/DateFormatter'\nimport moment from 'moment'\nimport { SkeletonTable } from '../assets/skeletons/SkeletonTable'\n\nexport type SubmissionInfoCardProps = {\n  info: SubmissionInfo\n}\n\nexport const SubmissionInfoCard: React.FunctionComponent<\n  SubmissionInfoCardProps\n> = ({ info }: SubmissionInfoCardProps) => {\n  return (\n    <>\n      {info && (\n        <p className=\"SubmissionInfoCard\">\n          <strong> Project Lead: </strong> <span>{info.projectLead}</span>{' '}\n          <br />\n          <strong> Institution: </strong> <span>{info.institution}</span> <br />\n          <strong> Data Access Request Submitted By: </strong>{' '}\n          <UserCard ownerId={info.submittedBy} size={SMALL_USER_CARD} /> <br />\n          <strong>\n            {' '}\n            Intended Data Use Statement &#40;accepted on{' '}\n            {formatDate(moment(info.modifiedOn), 'M/D/YYYY')}&#41;:\n          </strong>\n          <div>{info.intendedDataUseStatement}</div>\n          {info.accessorChanges &&\n            info.accessorChanges.map(accessorChange => (\n              <div key={`${accessorChange.userId}-${accessorChange.type}`}>\n                <UserCard\n                  ownerId={accessorChange.userId}\n                  size={SMALL_USER_CARD}\n                />{' '}\n                {accessorChange.type}\n              </div>\n            ))}\n        </p>\n      )}\n    </>\n  )\n}\n\nexport const LoadingSubmissionInfoCard: React.FunctionComponent = () => {\n  return (\n    <p className=\"SubmissionInfoCard\">\n      <SkeletonTable numCols={1} numRows={4} />\n      <Skeleton variant=\"rect\" width={'100%'} height={80} />\n    </p>\n  )\n}\n","import React, { useEffect } from 'react'\nimport { useInView } from 'react-intersection-observer'\nimport { useGetApprovedSubmissionInfoInfinite } from '../utils/hooks/SynapseAPI/useGetApprovedSubmissionInfo'\nimport { SubmissionInfo } from '../utils/synapseTypes/SubmissionInfo'\nimport {\n  LoadingSubmissionInfoCard,\n  SubmissionInfoCard,\n} from './IDUReportSubmissionInfo'\n\nexport type IDUReportProps = {\n  accessRequirementId: string\n}\n\nexport const IDUReport: React.FunctionComponent<IDUReportProps> = (\n  props: IDUReportProps,\n) => {\n  const { accessRequirementId } = props\n  // Load the next page when this ref comes into view.\n  const { ref, inView } = useInView()\n\n  const {\n    data,\n    status,\n    isLoading,\n    hasNextPage,\n    isFetchingNextPage,\n    fetchNextPage,\n  } = useGetApprovedSubmissionInfoInfinite(accessRequirementId, {\n    useErrorBoundary: true,\n  })\n  useEffect(() => {\n    if (\n      status === 'success' &&\n      !isFetchingNextPage &&\n      hasNextPage &&\n      fetchNextPage &&\n      inView\n    ) {\n      fetchNextPage()\n    }\n  }, [status, hasNextPage, isFetchingNextPage, fetchNextPage, inView])\n\n  const allRows = data?.pages.flatMap(page => page.results) ?? []\n\n  return (\n    <>\n      {allRows.length > 0 && (\n        <div className=\"IDUReport\">\n          {allRows.map((item: SubmissionInfo) => {\n            return (\n              <React.Fragment key={JSON.stringify(item)}>\n                <SubmissionInfoCard info={item} />\n                <hr />\n              </React.Fragment>\n            )\n          })}\n          {/* To trigger loading the next page */}\n          <div ref={ref} />\n        </div>\n      )}\n      {(isLoading || isFetchingNextPage) && (\n        <>\n          <LoadingSubmissionInfoCard />\n          <LoadingSubmissionInfoCard />\n        </>\n      )}\n    </>\n  )\n}\nexport default IDUReport\n","import * as React from 'react'\nimport { SynapseClient, SynapseConstants } from '../utils'\nimport { FileHandleResults, ObjectType, WikiPage } from '../utils/synapseTypes/'\nimport UserCard from './UserCard'\nimport Bookmarks from './widgets/Bookmarks'\nimport SynapseImage from './widgets/SynapseImage'\nimport SynapsePlot from './widgets/SynapsePlot'\nimport SynapseVideo from './widgets/SynapseVideo'\nimport { ErrorBanner } from './ErrorBanner'\nimport { SynapseClientError } from '../utils/SynapseClientError'\nimport { Button } from 'react-bootstrap'\nimport { SynapseContext } from '../utils/SynapseContext'\nimport IDUReport from './IDUReport'\n\nconst TOC_CLASS = {\n  1: 'toc-indent1',\n  2: 'toc-indent2',\n  3: 'toc-indent3',\n  4: 'toc-indent4',\n  5: 'toc-indent5',\n  6: 'toc-indent6',\n}\n\ndeclare var katex: any\n\ndeclare var markdownitSynapse: any\ndeclare var markdownit: any\ndeclare var markdownitSub: any\ndeclare var markdownitSup: any\ndeclare var markdownitCentertext: any\ndeclare var markdownitSynapseHeading: any\ndeclare var markdownitSynapseTable: any\ndeclare var markdownitStrikethroughAlt: any\ndeclare var markdownitContainer: any\ndeclare var markdownitEmphasisAlt: any\ndeclare var markdownitInlineComments: any\ndeclare var markdownitBr: any\ndeclare var sanitizeHtml: any\n\ndeclare var markdownitMath: any\n\nexport type MarkdownSynapseProps = {\n  ownerId?: string\n  wikiId?: string\n  markdown?: string\n  renderInline?: boolean\n  objectType?: ObjectType\n  onMarkdownProcessingDone?: (ref: HTMLInputElement | null) => void\n}\nconst md = markdownit({ html: true })\n\ntype MarkdownSynapseState = {\n  md: any\n  data: Partial<WikiPage>\n  fileHandles?: FileHandleResults\n  error: SynapseClientError | undefined\n  isLoading: boolean\n}\n/**\n * Basic Markdown functionality for Synapse, supporting Images/Plots/References/Bookmarks/buttonlinks\n *\n * @class Markdown\n * @extends {React.Component}\n */\nexport default class MarkdownSynapse extends React.Component<\n  MarkdownSynapseProps,\n  MarkdownSynapseState\n> {\n  public markupRef: React.RefObject<HTMLInputElement>\n  static contextType = SynapseContext\n  /**\n   * Creates an instance of Markdown.\n   * @param {*} props\n   */\n  constructor(props: MarkdownSynapseProps) {\n    super(props)\n    // markdownitSynapse wraps around markdownit object and uses its own dependencies\n    markdownitSynapse.init_markdown_it(\n      md,\n      markdownitSub,\n      markdownitSup,\n      markdownitCentertext,\n      markdownitSynapseHeading,\n      markdownitSynapseTable,\n      markdownitStrikethroughAlt,\n      markdownitContainer,\n      markdownitEmphasisAlt,\n      markdownitInlineComments,\n      markdownitBr,\n    )\n\n    const mathSuffix = ''\n    // Update the internal markdownit object with the wrapped synapse object\n    md.use(markdownitSynapse, mathSuffix, 'https://synapse.org').use(\n      markdownitMath,\n      mathSuffix,\n    )\n    const data: any = {}\n    if (this.props.markdown) {\n      data.markdown = this.props.markdown\n    }\n    this.state = {\n      md,\n      error: undefined,\n      fileHandles: undefined,\n      data,\n      isLoading: true,\n    }\n    this.markupRef = React.createRef()\n    this.handleLinkClicks = this.handleLinkClicks.bind(this)\n    // handle widgets and math markdown\n    this.renderMarkdown = this.renderMarkdown.bind(this)\n    this.recursiveRender = this.recursiveRender.bind(this)\n    this.processMath = this.processMath.bind(this)\n    // handle init calls to get wiki related items\n    this.getWikiAttachments = this.getWikiAttachments.bind(this)\n    this.getWikiPageMarkdown = this.getWikiPageMarkdown.bind(this)\n    // handle rendering widgets\n    this.renderWidget = this.renderWidget.bind(this)\n    this.renderSynapseButton = this.renderSynapseButton.bind(this)\n    this.renderSynapseImage = this.renderSynapseImage.bind(this)\n    this.renderVideo = this.renderVideo.bind(this)\n    this.renderSynapsePlot = this.renderSynapsePlot.bind(this)\n    this.renderSynapseTOC = this.renderSynapseTOC.bind(this)\n    this.createHTML = this.createHTML.bind(this)\n    this.addBookmarks = this.addBookmarks.bind(this)\n    this.addIdsToReferenceWidgets = this.addIdsToReferenceWidgets.bind(this)\n    this.addIdsToTocWidgets = this.addIdsToTocWidgets.bind(this)\n  }\n\n  public componentWillUnmount() {\n    // @ts-ignore TODO: find better documentation on typescript/react event params\n    this.markupRef.current &&\n      // @ts-ignore TODO: find better documentation on typescript/react event params\n      this.markupRef.current.removeEventListener('click', this.handleLinkClicks)\n  }\n\n  // Manually handle clicks to anchor tags where the scrollto isn't handled by page hash\n  public handleLinkClicks(event: React.MouseEvent<HTMLElement>) {\n    const genericElement = event.target as HTMLElement\n    if (genericElement.tagName === 'A' || genericElement.tagName === 'BUTTON') {\n      const anchor = event.target as HTMLAnchorElement\n      if (anchor.id.substring(0, 3) === 'ref') {\n        event.preventDefault()\n        // its a reference, so we scroll to the appropriate bookmark\n        const referenceNumber = Number(event.currentTarget.id.substring(3)) // e.g. ref2 => '2'\n        const goTo = this.markupRef.current!.querySelector(\n          `#bookmark${referenceNumber}`,\n        )\n        try {\n          goTo!.scrollIntoView({\n            behavior: 'smooth',\n            block: 'center',\n            inline: 'center',\n          })\n        } catch (e) {\n          console.log('error on scroll', e)\n        }\n      } else if (\n        event.currentTarget.id !== null &&\n        anchor.getAttribute('data-anchor')\n      ) {\n        event.preventDefault()\n        // handle table of contents widget\n        const idOfContent = anchor.getAttribute('data-anchor')\n        const goTo = this.markupRef.current!.querySelector(`#${idOfContent}`)\n        try {\n          goTo!.scrollIntoView({\n            behavior: 'smooth',\n            block: 'center',\n            inline: 'center',\n          })\n        } catch (e) {\n          console.log('error on scroll', e)\n        }\n      }\n    }\n  }\n\n  /**\n   * Given input text, generate markdown object to be passed onto inner html of some container.\n   * @param {String} markdown The text being written in plain markdown\n   * @returns {Object} Dictionary to be passed into dangerouslySetInnerHTML with markdown text\n   */\n  public createHTML(markdown?: string) {\n    if (!markdown) {\n      return { __html: '' }\n    }\n    // Note - renderInline parses out any block level elements contained in the markdown\n    const initText = this.props.renderInline\n      ? this.state.md.renderInline(markdown)\n      : this.state.md.render(markdown)\n    const cleanText = sanitizeHtml(initText, {\n      allowedAttributes: {\n        a: ['href', 'target'],\n        button: ['class'],\n        div: ['class'], // PORTALS-1450: including 'style' in the allow-list will cause string values to come through, which crashes the app when used (because it uses jsx).\n        h1: ['toc'],\n        h2: ['toc'],\n        h3: ['toc'],\n        h4: ['toc'],\n        h5: ['toc'],\n        h6: ['toc'],\n        li: ['class'],\n        ol: ['class'],\n        span: ['*'],\n        table: ['class'],\n        th: ['colspan'],\n        thead: ['class'],\n        ul: ['class'],\n        img: ['src', 'alt'],\n      },\n      allowedTags: [\n        'span',\n        'code',\n        'h1',\n        'h2',\n        'h3',\n        'h4',\n        'h5',\n        'p',\n        'b',\n        'i',\n        'em',\n        'strong',\n        'a',\n        'id',\n        'table',\n        'tr',\n        'td',\n        'tbody',\n        'th',\n        'thead',\n        'button',\n        'div',\n        'img',\n        'image',\n        'ol',\n        'ul',\n        'li',\n        'svg',\n        'g',\n        'br',\n        'hr',\n        'summary',\n        'details',\n        'strong',\n      ],\n    })\n    return { __html: cleanText }\n  }\n\n  /**\n   * Find all math identified elements of the form [id^=\\\"mathjax-\\\"]\n   * (e.g. <dom element id=\"mathjax-10\"> text </dom element>)\n   * and transform them to their math markedown equivalents\n   */\n  public processMath() {\n    if (!this.markupRef.current) {\n      return\n    }\n    // use regex to grab all elements\n    const mathExpressions =\n      this.markupRef.current.querySelectorAll<HTMLElement>('[id^=\"mathjax-\"]')\n    // go through all obtained elements and transform them with katex\n    const regEx = new RegExp(/\\\\[()[\\]]/, 'g') // Look for a '\\' followed by either '(', ')', '[', or ']'. We delete these strings since they interfere with katex processing.\n    mathExpressions.forEach(element => {\n      if (element.textContent && !element.getAttribute('processed')) {\n        // only process a math element once, used to double/triple process\n        element.setAttribute('processed', 'true')\n        const textContent = element.textContent.replace(regEx, '')\n        return katex.render(textContent, element, {\n          // @ts-ignore\n          output: 'html',\n          throwOnError: false,\n        })\n      }\n    })\n  }\n  /**\n   * Process all the corresponding bookmark tags of the references made throughout the page\n   *\n   * @memberof MarkdownSynapse\n   */\n  public addBookmarks() {\n    markdownitSynapse.resetFootnotes()\n    this.createHTML(this.state.data.markdown)\n    const footnotesHtml = this.createHTML(markdownitSynapse.footnotes()).__html\n    if (footnotesHtml.length > 0) {\n      return <Bookmarks footnotes={footnotesHtml} />\n    }\n    return\n  }\n\n  /**\n   * Get wiki page markdown and file attachment handles\n   */\n  public async getWikiPageMarkdown() {\n    const { ownerId, wikiId, objectType } = this.props\n    if (!ownerId && !wikiId) {\n      return\n    }\n    try {\n      const wikiPage = await SynapseClient.getEntityWiki(\n        this.context.accessToken,\n        ownerId,\n        wikiId,\n        objectType,\n      )\n      try {\n        const fileHandles = await this.getWikiAttachments(\n          wikiId ? wikiId : wikiPage.id,\n        )\n        this.setState({\n          data: wikiPage,\n          fileHandles,\n          error: undefined,\n        })\n      } catch (fileHandlesErr) {\n        console.error('fileHandlesErr = ', fileHandlesErr)\n      }\n    } catch (err) {\n      console.error('Error on wiki markdown load\\n', err)\n      this.setState({\n        error: err,\n      })\n    }\n  }\n  public async getWikiAttachments(wikiId: string) {\n    const { ownerId, objectType } = this.props\n    if (!ownerId) {\n      console.error(\n        'Cannot get wiki attachments without ownerId on Markdown Component',\n      )\n      return undefined\n    }\n    return await SynapseClient.getWikiAttachmentsFromEntity(\n      this.context.accessToken,\n      ownerId,\n      wikiId,\n      objectType,\n    )\n      .then(data => {\n        return data\n      })\n      .catch(err => {\n        console.error('Error on wiki attachment load ', err)\n        return undefined\n      })\n  }\n\n  public addIdsToReferenceWidgets(text: string) {\n    const referenceRegex =\n      /<span id=\"wikiReference.*?<span data-widgetparams.*?span>/g\n    let referenceCount = 1\n\n    return text.replace(referenceRegex, () => {\n      // replace all reference tags with id's of the form id=\"ref<number>\"\" that we can read onClick\n      const current = referenceCount\n      referenceCount += 1\n      return `<a href=\"\" id=\"ref${current}\">[${current}]</a>`\n    })\n  }\n\n  public addIdsToTocWidgets(text: string) {\n    const tocId = 'SRC-header-'\n    let tocIdCount = 1\n    const TOC_HEADER_REGEX = /<h[1-6] toc=\"true\">.*<\\/h[1-6]>/gm\n\n    return text.replace(TOC_HEADER_REGEX, (match: string) => {\n      // replace with id of the form id=\"toc\" so we can read them with onclick events\n      const curTocId = tocIdCount\n      tocIdCount += 1\n      const matchWithId = `${match.substring(\n        0,\n        3,\n      )} id=\"${tocId}${curTocId}\"${match.substring(3)}`\n      return matchWithId\n    })\n  }\n\n  /**\n   * The 'main' method of this class that process all the markdown and transforms it to the appropriate\n   * Synapse widgets.\n   *\n   * @returns JSX of the markdown into widgets\n   * @memberof MarkdownSynapse\n   */\n  public renderMarkdown() {\n    // create initial markup\n    let markup = this.createHTML(this.state.data.markdown).__html\n    // process reference widgets\n    markup = this.addIdsToReferenceWidgets(markup)\n    // process table of contents widgets\n    markup = this.addIdsToTocWidgets(markup)\n    if (markup.length > 0) {\n      const domParser = new DOMParser()\n      const document = domParser.parseFromString(markup, 'text/html')\n      return <>{this.recursiveRender(document.body, markup)}</>\n    }\n    return\n  }\n\n  /**\n   * recursiveRender will render react tree from HTML tree\n   *\n   * @param {Node} element This will be either a text Node or an HTMLElement\n   * @param {string} markdown The original markdown, its kept as a special case for the table of contents widget\n   * @returns {*}\n   * @memberof MarkdownSynapse\n   */\n  public recursiveRender(element: Node, markdown: string): any {\n    /*\n      Recursively render the html tree created from the markdown, there are a few cases:\n      1. element is Node and is text in which case it is simply rendered\n      2. element is an HTMLElement and is: a self closing tag, has no children (e.g. <br>), or its a synapse widget and is \n      rendered accordingly\n      3. element is an HTMLElement and has children so we loop through its childNodes, recurively render those, and then render its own tag\n      as the parent of those child nodes. Note - childNodes was specifically chosen over .children because text Nodes\n      would not come through .children\n    */\n    if (element.nodeType === Node.TEXT_NODE) {\n      // case 1.\n      return <> {element.textContent} </>\n    } else if (\n      element.nodeType === Node.ELEMENT_NODE &&\n      element instanceof HTMLElement\n    ) {\n      const tagName =\n        element.tagName.toLowerCase() === 'body'\n          ? 'span'\n          : element.tagName.toLowerCase()\n      const widgetParams = element.getAttribute('data-widgetparams')\n      if (widgetParams) {\n        // case 2\n        // process widget\n        return this.processHTMLWidgetMapping(widgetParams, markdown)\n      }\n      // manually add on props, depending on what comes through the markdown their could\n      // be unforseen issues with attributes being misnamed according to what react will respect\n      // e.g. class instead of className\n      const attributes = element.attributes\n      const props = {}\n      for (let i = 0; i < attributes.length; i++) {\n        let name = ''\n        let value = ''\n        const attribute = attributes.item(i)\n        if (attribute) {\n          name = attribute.name\n          value = attribute.value\n        }\n        if (name && value) {\n          props[name] = value\n        }\n      }\n      if (element.childNodes.length === 0) {\n        // case 2\n        // e.g. self closing tag like <br/> or <img>\n        return React.createElement(tagName, props)\n      }\n      // case 3\n      // recursively render children\n      const children = Array.from(element.childNodes).map((el, index) => {\n        return (\n          <React.Fragment key={index}>\n            {this.recursiveRender(el, markdown)}\n          </React.Fragment>\n        )\n      })\n      // Render tagName as parent element of the children below\n      return React.createElement(tagName, props, <>{children}</>)\n    }\n  }\n\n  /**\n   *  When the markdown string is transfered over the network certain characters get transformed,\n   * this does a simple transformation back to the original user's string.\n   *\n   * @param {string} xml\n   * @returns\n   * @memberof MarkdownSynapse\n   */\n  public decodeXml(xml: string) {\n    const escapedOneToXmlSpecialMap = {\n      '&amp;': '&',\n      '&gt;': '>',\n      '&lt;': '<',\n      '&quot;': '\"',\n    }\n    return xml.replace(/(&quot;|&lt;|&gt;|&amp;)/g, (str, item) => {\n      return escapedOneToXmlSpecialMap[item]\n    })\n  }\n\n  /**\n   * Given widgetMap renders it in a React component (or originalMarkup in special cases.)\n   *\n   * @param {string} widgetMatch The synapse widget to be rendered\n   * @param {string} originalMarkup The original markup text, this is a special case for widgets that\n   * are html specific.\n   * @returns JSX of the widget to render\n   * @memberof MarkdownSynapse\n   */\n  public processHTMLWidgetMapping(\n    widgetParams: string,\n    originalMarkup: string,\n  ) {\n    // General workflow -\n    //   1. Capture widget parameters\n    //   2. Transform any widget xml parameters to standard text\n    //   3. Split those parameters into a map\n    //   4. Render that widget based on its parameters\n\n    // steps 1,2\n    const decodedWidgetParams = this.decodeXml(widgetParams)\n\n    // decodedWidgetParams look like {<widget>?param1=xxx&param2=yyy}\n    const questionIndex = decodedWidgetParams.indexOf('?')\n    if (questionIndex === -1) {\n      // e.g. toc is passed, there are no params\n      return this.renderWidget(decodedWidgetParams, {}, originalMarkup)\n    }\n    const widgetType = decodedWidgetParams.substring(0, questionIndex)\n    const widgetparamsMapped = {}\n    // map out params and their values\n    decodedWidgetParams\n      .substring(questionIndex + 1)\n      .split('&')\n      .forEach(keyPair => {\n        let [key, value] = keyPair.split('=')\n        value = decodeURIComponent(value)\n        widgetparamsMapped[key] = value\n      })\n    return this.renderWidget(widgetType, widgetparamsMapped, originalMarkup)\n  }\n\n  /**\n   *  Given widgetType renders the apppropriate widget\n   *\n   * @param {string} widgetType The type of synapse widget. (e.g. 'image', 'plot')\n   * @param {*} widgetparamsMapped The parameters for this widget\n   * @param {string} originalMarkup The original markup.\n   * @returns\n   * @memberof MarkdownSynapse\n   */\n  public renderWidget(\n    widgetType: string,\n    widgetparamsMapped: any,\n    originalMarkup: string,\n  ) {\n    // we make keys out of the widget params\n    const key = JSON.stringify(widgetparamsMapped)\n    widgetparamsMapped.reactKey = key\n\n    switch (widgetType) {\n      case 'buttonlink':\n        return this.renderSynapseButton(widgetparamsMapped)\n      case 'image':\n        return this.renderSynapseImage(widgetparamsMapped)\n      case 'plot':\n        return this.renderSynapsePlot(widgetparamsMapped)\n      case 'toc':\n        return this.renderSynapseTOC(originalMarkup)\n      case 'badge':\n        return this.renderUserBadge(widgetparamsMapped)\n      case 'iduReport':\n        return this.renderIntendedDataUseReport(widgetparamsMapped)\n      case 'video':\n      case 'vimeo':\n      case 'youtube':\n        return this.renderVideo(widgetparamsMapped)\n      default:\n        return\n    }\n  }\n\n  public renderSynapseButton(widgetparamsMapped: any) {\n    let buttonClasses = 'pill-xl '\n    const { align = '', highlight = '' } = widgetparamsMapped\n    const alignLowerCase = align.toLowerCase()\n    if (alignLowerCase === 'left') {\n      buttonClasses += 'floatLeft '\n    }\n    if (alignLowerCase === 'right') {\n      buttonClasses += 'floatright '\n    }\n    const buttonVariant = highlight === 'true' ? 'secondary' : 'light-secondary'\n    if (alignLowerCase === 'center') {\n      return (\n        <div\n          key={widgetparamsMapped.reactKey}\n          className=\"bootstrap-4-backport\"\n          style={{ textAlign: 'center' }}\n        >\n          <Button\n            href={widgetparamsMapped.url}\n            className={buttonClasses}\n            variant={buttonVariant}\n          >\n            {widgetparamsMapped.text}\n          </Button>\n        </div>\n      )\n    }\n    return (\n      <span className=\"bootstrap-4-backport\">\n        <Button\n          href={widgetparamsMapped.url}\n          className={buttonClasses}\n          variant={buttonVariant}\n        >\n          {widgetparamsMapped.text}\n        </Button>\n      </span>\n    )\n  }\n  public renderSynapsePlot(widgetparamsMapped: any) {\n    return (\n      <SynapsePlot\n        key={widgetparamsMapped.reactKey}\n        ownerId={this.props.ownerId}\n        wikiId={this.props.wikiId || this.state.data.id}\n        widgetparamsMapped={widgetparamsMapped}\n      />\n    )\n  }\n\n  public renderVideo(widgetparamsMapped: any) {\n    return <SynapseVideo params={widgetparamsMapped} />\n  }\n\n  public renderSynapseImage(widgetparamsMapped: any) {\n    const { reactKey } = widgetparamsMapped\n    if (widgetparamsMapped.fileName) {\n      if (!this.state.fileHandles) {\n        // ensure files are loaded\n        return\n      }\n      // if file name is attached then the fileHandle ID is located\n      // in this wiki's file attachment list\n      return (\n        <SynapseImage\n          params={widgetparamsMapped}\n          key={reactKey}\n          fileName={widgetparamsMapped.fileName}\n          wikiId={this.props.wikiId || this.state.data.id}\n          fileResults={this.state.fileHandles.list}\n        />\n      )\n    }\n    if (widgetparamsMapped.synapseId) {\n      // otherwise this image's fileHandle ID is not located\n      // in the file attachment list and will be loaded first\n      return (\n        <SynapseImage\n          params={widgetparamsMapped}\n          key={reactKey}\n          synapseId={widgetparamsMapped.synapseId}\n        />\n      )\n    }\n    return\n  }\n  public renderSynapseTOC(originalMarkup: string) {\n    const elements: any[] = []\n    const TOC_HEADER_REGEX_WITH_ID =\n      /<h([1-6]) id=\"(.*)\" .*toc=\"true\">(.*)<\\/h[1-6]>/gm\n    let text = ''\n    originalMarkup.replace(TOC_HEADER_REGEX_WITH_ID, (p1, p2, p3, p4) => {\n      text += p4\n      elements.push(\n        <div key={p4}>\n          <a\n            role=\"link\"\n            className={`link ${TOC_CLASS[Number(p2)]}`}\n            data-anchor={p3}\n          >\n            {p4}\n          </a>\n        </div>,\n      )\n      return ''\n    })\n    return <div key={text}>{elements}</div>\n  }\n\n  public renderUserBadge(widgetparamsMapped: any) {\n    return (\n      <UserCard\n        key={JSON.stringify(widgetparamsMapped)}\n        size={SynapseConstants.SMALL_USER_CARD}\n        alias={widgetparamsMapped.alias}\n      />\n    )\n  }\n\n  public renderIntendedDataUseReport(widgetparamsMapped: any) {\n    return (\n      <IDUReport\n        key={JSON.stringify(widgetparamsMapped)}\n        accessRequirementId={widgetparamsMapped.accessRestrictionId}\n      />\n    )\n  }\n\n  public async componentDidMount() {\n    if (this.state.data.markdown) {\n      this.setState({ isLoading: false })\n      if (this.props.onMarkdownProcessingDone) {\n        this.props.onMarkdownProcessingDone(this.markupRef.current)\n      }\n      return\n    }\n    // we use this.markupRef.current && because in testing environment refs aren't defined\n    // @ts-ignore\n    this.markupRef.current &&\n      // @ts-ignore\n      this.markupRef.current!.addEventListener('click', this.handleLinkClicks)\n    // unpack and set default value if not specified\n    // get wiki attachments\n    await this.getWikiPageMarkdown()\n    this.processMath()\n    this.setState({ isLoading: false })\n    if (this.props.onMarkdownProcessingDone) {\n      this.props.onMarkdownProcessingDone(this.markupRef.current)\n    }\n  }\n\n  // on component update find and re-render the math/widget items accordingly\n  public async componentDidUpdate(prevProps: MarkdownSynapseProps) {\n    let shouldUpdate = this.props.ownerId !== prevProps.ownerId\n    shouldUpdate = shouldUpdate || this.props.wikiId !== prevProps.wikiId\n\n    // we have to carefully update the component so it doesn't encounter an infinite loop\n    if (shouldUpdate) {\n      await this.getWikiPageMarkdown()\n    }\n    this.processMath()\n  }\n\n  public render() {\n    const { renderInline } = this.props\n    const { isLoading, error } = this.state\n\n    if (error) {\n      return <ErrorBanner error={error} />\n    }\n    const bookmarks = this.addBookmarks()\n    const content = (\n      <>\n        {isLoading && <span className=\"spinner\" />}\n        {this.renderMarkdown()}\n        {bookmarks && <div>{this.addBookmarks()}</div>}\n      </>\n    )\n    if (renderInline) {\n      return (\n        <span className=\"markdown markdown-inline\" ref={this.markupRef}>\n          {content}\n        </span>\n      )\n    }\n    return (\n      <div className=\"markdown\" ref={this.markupRef}>\n        {content}\n      </div>\n    )\n  }\n}\n"],"names":["React","output","_jsxs","index","_jsx","el","synapseId","getEntity","FileEntity","dataFileHandleId","getFiles","fileHandleAssociationList","preSignedURL","console","fileName","id","wikiId","WikiAttachment","params","scale","className","altText","SynapseImage","query","SynapseConstants.BUNDLE_MASK_QUERY_RESULTS","BUNDLE_MASK_QUERY_RESULTS","getFullQueryTableResults","data","title","xtitle","ytitle","type","xaxistype","showlegend","layout","xaxis","plotData","orientation","name","SynapsePlot","SynapseClient.getApprovedSubmissionInfo","_Fragment","projectLead","institution","submittedBy","SMALL_USER_CARD","moment","intendedDataUseStatement","userId","accessRequirementId","ref","inView","status","isLoading","hasNextPage","isFetchingNextPage","fetchNextPage","useEffect","item","markdownitSynapse","md","undefined","event","goTo","cleanText","mathExpressions","element","Bookmarks","footnotesHtml","ownerId","objectType","SynapseClient.getEntityWiki","wikiPage","fileHandles","err","SynapseClient.getWikiAttachmentsFromEntity","referenceCount","current","tocIdCount","matchWithId","markup","value","props","decodedWidgetParams","widgetparamsMapped","widgetType","buttonClasses","url","buttonVariant","text","reactKey","list","originalMarkup","elements","p3","p4","SynapseConstants.SMALL_USER_CARD","alias","IDUReport","accessRestrictionId","shouldUpdate","renderInline","error","markupRef","content","MarkdownSynapse"],"mappings":"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"}