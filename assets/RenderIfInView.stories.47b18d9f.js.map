{"version":3,"file":"RenderIfInView.stories.47b18d9f.js","sources":["../../src/lib/containers/VisibilityObserver.tsx","../../src/lib/containers/RenderIfInView.tsx"],"sourcesContent":["/** Originally from YamUI.  May need to alter to update to later versions of react-intersection-observer (which does the heavy lifting).\n * This component has the option to provide an outOfView renderer, which might be useful in the future.\n */\nimport * as React from 'react'\nimport Observer from 'react-intersection-observer'\n\nexport interface BaseComponentProps {\n  /**\n   * One or more class names to be added to the root element of this component, i.e.\n   * `\"class-one class-two\"`.\n   */\n  className?: string\n}\n\nexport interface NestableBaseComponentProps extends BaseComponentProps {\n  /**\n   * Elements to be rendered as children of this component.\n   */\n  children?: React.ReactNode\n}\n\nexport interface VisibilityObserverProps extends BaseComponentProps {\n  /**\n   * A callback which will be triggered when the component is scrolled into view.\n   */\n  onEnterView?: () => void\n\n  /**\n   * A callback which will be triggered when the component is scrolled out of view.\n   */\n  onLeaveView?: () => void\n\n  /**\n   * Render prop to return child content when the component is visible in the viewport. Once the component\n   * has been in view it will always use this render prop, even when scrolled back out of view.\n   */\n  renderInView?: () => React.ReactNode\n\n  /**\n   * Render prop to return child content before the component becomes visible in the viewport.\n   */\n  renderOutOfView?: () => React.ReactNode\n\n  /**\n   * Wrapper element tag name.\n   * @default 'div'\n   */\n  tag?: string\n\n  /**\n   * A CSS margin string which pushes the intersection boundary further in or out of the viewport.\n   * A positive value will expand the viewport threshold so your component is considered \"in view\" while it's\n   * still offscreen, for example you could set thresholdOffset=\"200px\" you want an image to start loading before\n   * it scrolls into view. A negative value will move the boundary into the viewport, triggering \"in view\" after\n   * it's already becoming visible.\n   * \"200px\", \"200px 0 50px 0\", \"-50px\" are all valid values.\n   */\n  rootMargin?: string\n}\n\nexport interface VisibilityObserverState {\n  hasBeenInView: boolean\n}\n\n/**\n * VisibilityObserver uses the IntersectionObserver API to allow conditional child rendering and callbacks based\n * on viewport visibility. It will render the `renderOutOfView` prop until it is scrolled into view, then will\n * always render the `renderInView` prop instead. Callbacks will always be triggered on visibility changes.\n */\nexport default class VisibilityObserver extends React.Component<\n  VisibilityObserverProps,\n  VisibilityObserverState\n> {\n  constructor(props: VisibilityObserverProps) {\n    super(props)\n    this.state = {\n      hasBeenInView: false,\n    }\n  }\n\n  public render() {\n    const { rootMargin, tag } = this.props\n\n    return (\n      <Observer\n        as={(tag as any) || 'div'}\n        rootMargin={rootMargin}\n        onChange={this.onVisibilityChange}\n      >\n        {this.getObserverChildren}\n      </Observer>\n    )\n  }\n\n  private getObserverChildren = (isVisible: boolean) => {\n    const { renderInView, renderOutOfView } = this.props\n    const shouldRenderAsInView = isVisible || this.state.hasBeenInView\n\n    if (shouldRenderAsInView && renderInView) {\n      return renderInView()\n    }\n\n    if (!isVisible && renderOutOfView) {\n      return renderOutOfView()\n    }\n\n    return null\n  }\n\n  private onVisibilityChange = (isVisible: boolean) => {\n    if (isVisible) {\n      this.setState({ hasBeenInView: true })\n      if (this.props.onEnterView) {\n        this.props.onEnterView()\n      }\n    } else {\n      if (this.props.onLeaveView) {\n        this.props.onLeaveView()\n      }\n    }\n  }\n}\n","import * as React from 'react'\nimport VisibilityObserver from './VisibilityObserver'\n\nexport default class RenderIfInView extends React.Component {\n  public render() {\n    return <VisibilityObserver renderInView={this.getChildren} />\n  }\n\n  private getChildren = () => {\n    return <>{this.props.children}</>\n  }\n}\n"],"names":["React","renderInView","renderOutOfView","rootMargin","tag","_jsx","Observer","onVisibilityChange","getObserverChildren","_Fragment","children","getChildren"],"mappings":"qHAGA,KAAAA,GAAA,OAAA,MAkEA,MAAA,SAAAA,GAAA,SAAA,CAGE,YAAA,EAAA,CAEE,MAAA,CAAA,EAoByB,KAAA,oBAAA,AAAA,GAAA,CACzB,KAAA,CAAM,eAAEC,mBAAcC,KAAAA,MAGtB,MAAA,AAFA,IAAA,KAAA,MAAA,gBAEA,EACE,EAAA,EAGF,CAAA,GAAA,EACE,EAAA,EAGF,IAAO,EAGiB,KAAA,mBAAA,AAAA,GAAA,CACxB,AAAA,EACE,MAAA,SAAA,CAAc,cAAA,EAAiB,CAAA,EAC/B,KAAA,MAAA,aACE,KAAA,MAAA,eAGF,KAAA,MAAA,aACE,KAAA,MAAA,aAEH,EA5CD,KAAA,MAAA,CAAa,cAAA,EACI,CADJ,CAGd,QAAA,CAGC,KAAA,CAAM,aAAEC,OAAYC,KAAAA,MAEpB,MAAAC,GAAAC,EAAA,CACE,GAAA,GAAA,MACsB,aACpB,SAAA,KAAA,mBACeC,SAAAA,KAAAA,mBAETC,CAAAA,CANV,CAXF;;;;;;gkBCxEF,KAAA,GAAA,OAAA,MAGA,MAAA,SAAA,GAAA,SAAA,CAA4D,aAAA,CAA5D,MAAA,GAAA,SAAA,EAKqB,KAAA,YAAA,IACjBH,EAAAI,EAAA,CAAO,SAAA,KAAA,MAAA,QAAcC,CAAAA,CACtB,CAAA,QAAA,CALC,MAAAL,GAAA,EAAA,CAAO,aAAA,KAAA,WAAuCM,CAAAA,CAA9C,CAFwD;;;;;;;;;;;;;;;;;;;;;;"}