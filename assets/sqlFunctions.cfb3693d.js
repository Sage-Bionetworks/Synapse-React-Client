import{S as u}from"./RegularExpressions.3cd69849.js";const R=window.SQLParser.lexer,p=window.SQLParser.parser,x=/group by/im,l=e=>x.test(e),O=3,T=(e,r,n)=>{let s=n;n.match(u)&&(s=n.substring(O));const i=n.split(",").map(t=>`'${t}'`).join(",");switch(r){case"LIKE":return[["LITERAL",e,"1"],["OPERATOR",r,"1"],["STRING",`%${s}%`,"1"]];case"HAS":return[["LITERAL",e,"1"],["OPERATOR",r,"1"],["PARAMETER",`(${i})`,"1"]];default:return[["LITERAL",e,"1"],["OPERATOR",r,"1"],["STRING",n,"1"]]}},L=e=>{const r=e.findIndex(s=>s[0]==="WHERE");if(r!==-1)return r;let n=e.findIndex(s=>s[0]==="GROUP");return n!==-1||(n=e.findIndex(s=>s[0]==="HAVING"),n!==-1)||(n=e.findIndex(s=>s[0]==="ORDER"),n!==-1)||(n=e.findIndex(s=>s[0]==="EOF")),n},m=(e,r,n="LIKE")=>{if(!r)return e;const s=I=>I.startsWith("QueryWrapper"),i=Object.keys(r);if(i.length===0||i.every(s))return e;const t=R.tokenize(e),o=t.findIndex(I=>I[0]==="WHERE"),c=L(t),d=c+1;o===-1?t.splice(c,0,["WHERE","WHERE","1"]):t.splice(d,0,["CONDITIONAL","AND","1"]);const E=Object.keys(r).length;return Object.keys(r).forEach((I,f)=>{const a=T(I,n,r[I]);f<E-1&&a.unshift(["CONDITIONAL","AND","1"]),t.splice(d,0,...a)}),A(t)},A=e=>{e.forEach(t=>{t[0]==="DBLSTRING"&&(t[0]="LITERAL")});const r=e.findIndex(t=>t[0]==="DOT");if(r!==-1){const t=e[r-1][1],o=e[r+1][1],c=`${t}.${o}`;e.splice(r,2),e[r-1]=["LITERAL",c]}const n=p.parse(e).toString(),s=e[e.findIndex(t=>t[0]==="FROM")+1][1],i=`\`${s}\``;return n.replace(i,s)},y=e=>{const r=e.match(/(from)\s+(syn)\d+/gi);return r&&r[0]?r[0].substr(5).trim():""},h=e=>{const n=/from\s+(syn\d+)(?:\.(\d+))?/i.exec(e);return n?{entityId:n[1],versionNumber:n[2]?parseInt(n[2]):void 0}:null},N=(e,r)=>{const n=[],s=r.map(t=>t.values),i=e.map(t=>t.name);return s.forEach((t,o)=>{n[o]={},t.forEach((c,d)=>{n[o][i[d]]=c})}),n};export{h as a,m as b,A as f,l as i,y as p,N as r};
