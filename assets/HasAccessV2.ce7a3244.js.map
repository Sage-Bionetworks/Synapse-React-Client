{"version":3,"file":"HasAccessV2.ce7a3244.js","sources":["../../src/lib/utils/synapseTypes/Entity/FileEntity.ts","../../src/lib/containers/HasAccessV2.tsx"],"sourcesContent":["import { VersionableEntity } from './Entity'\nimport { isTypeViaConcreteTypeFactory } from '../../functions/TypeUtils'\n\nexport const FILE_ENTITY_CONCRETE_TYPE_VALUE =\n  'org.sagebionetworks.repo.model.FileEntity'\nexport type FILE_ENTITY_CONCRETE_TYPE = typeof FILE_ENTITY_CONCRETE_TYPE_VALUE\n\n// https://rest-docs.synapse.org/rest/org/sagebionetworks/repo/model/FileEntity.html\nexport interface FileEntity extends VersionableEntity {\n  concreteType: FILE_ENTITY_CONCRETE_TYPE\n  dataFileHandleId: string // \tID of the file associated with this entity.\n  fileNameOverride?: string // \tAn optional replacement for the name of the uploaded file. This is distinct from the entity name. If omitted the file will retain its original name.\n}\n\nexport const isFileEntity = isTypeViaConcreteTypeFactory<FileEntity>(\n  FILE_ENTITY_CONCRETE_TYPE_VALUE,\n)\n","import React from 'react'\nimport { SynapseClient } from '../utils'\nimport {\n  BackendDestinationEnum,\n  getEndpoint,\n} from '../utils/functions/getEndpoint'\nimport { useGetRestrictionInformation } from '../utils/hooks/SynapseAPI/dataaccess/useGetAccessRequirement'\nimport useGetEntityBundle from '../utils/hooks/SynapseAPI/entity/useEntityBundle'\nimport { SynapseTheme, ThemeContext } from '../utils/hooks/useTheme'\nimport { SRC_SIGN_IN_CLASS } from '../utils/SynapseConstants'\nimport { useSynapseContext } from '../utils/SynapseContext'\nimport {\n  AccessRequirement,\n  isFileEntity,\n  RestrictableObjectType,\n  RestrictionInformationRequest,\n  RestrictionLevel,\n} from '../utils/synapseTypes/'\nimport AccessRequirementList, {\n  checkHasUnsportedRequirement,\n} from './access_requirement_list/AccessRequirementList'\nimport IconSvg, { Icon } from './IconSvg'\n\nexport type HasAccessProps = {\n  onHide?: () => void\n  entityId: string\n  entityVersionNumber?: string\n  className?: string\n}\n\nexport const GIGABYTE_SIZE = 2 ** 30\n\nexport enum FileHandleDownloadTypeEnum {\n  Accessible = 'Accessible',\n  AccessBlockedByRestriction = 'AccessBlockedByRestriction',\n  AccessBlockedByACL = 'AccessBlockedByACL',\n  AccessBlockedToAnonymous = 'AccessBlockedToAnonymous',\n  NoFileHandle = 'NoFileHandle',\n}\n\nconst iconConfiguration: Record<\n  FileHandleDownloadTypeEnum,\n  { icon: Icon; color: (theme: SynapseTheme) => string; tooltipText: string }\n> = {\n  [FileHandleDownloadTypeEnum.AccessBlockedToAnonymous]: {\n    icon: 'accessClosed',\n    color: theme => theme.colors.warning,\n    tooltipText: 'You must sign in to access this file.',\n  },\n  [FileHandleDownloadTypeEnum.AccessBlockedByRestriction]: {\n    icon: 'accessClosed',\n    color: theme => theme.colors.warning,\n    tooltipText: 'You must request access to this restricted file.',\n  },\n  [FileHandleDownloadTypeEnum.AccessBlockedByACL]: {\n    icon: 'accessClosed',\n    color: theme => theme.colors.warning,\n    tooltipText: 'You do not have download access for this item.',\n  },\n\n  [FileHandleDownloadTypeEnum.Accessible]: {\n    icon: 'accessOpen',\n    color: theme => theme.colors.success,\n    tooltipText: '',\n  },\n\n  [FileHandleDownloadTypeEnum.NoFileHandle]: {\n    icon: 'accessOpen',\n    color: theme => theme.colors.success,\n    tooltipText: '',\n  },\n}\n\nfunction AccessIcon(props: { downloadType: FileHandleDownloadTypeEnum }) {\n  const { downloadType } = props\n  if (downloadType) {\n    const configuration = iconConfiguration[downloadType]\n    return (\n      <ThemeContext.Consumer>\n        {theme => (\n          <IconSvg\n            options={{\n              icon: configuration.icon,\n              color: configuration.color(theme),\n              label: configuration.tooltipText,\n            }}\n          />\n        )}\n      </ThemeContext.Consumer>\n    )\n  }\n  // nothing is rendered until downloadType is determined\n  return <></>\n}\n\n/**\n * Determines whether an Entity is accessible for download, or if it is blocked by the ACL or unmet Access Requirements.\n *\n * To make download available, and determine if the file is downloadable via the web, see {@link DirectDownload.tsx}\n * @param entityId\n * @param entityVersionNumber\n * @returns\n */\nexport function useGetFileHandleDownloadType(\n  entityId: string,\n  entityVersionNumber?: string,\n) {\n  const [fileHandleDownloadType, setFileHandleDownloadType] =\n    React.useState<FileHandleDownloadTypeEnum>()\n\n  const { accessToken } = useSynapseContext()\n  const { data: entityBundle, error: entityFetchError } = useGetEntityBundle(\n    entityId,\n    {\n      includeEntity: true,\n      includePermissions: true,\n    },\n    parseInt(entityVersionNumber ?? ''),\n  )\n\n  const restrictionInformationRequest: RestrictionInformationRequest =\n    React.useMemo(\n      () => ({\n        restrictableObjectType: RestrictableObjectType.ENTITY,\n        objectId: entityId,\n      }),\n      [entityId],\n    )\n\n  const { data: restrictionInformation } = useGetRestrictionInformation(\n    restrictionInformationRequest,\n  )\n\n  const entity = entityBundle?.entity\n  const permissions = entityBundle?.permissions\n\n  React.useEffect(() => {\n    if (\n      restrictionInformation &&\n      restrictionInformation.hasUnmetAccessRequirement\n    ) {\n      setFileHandleDownloadType(\n        FileHandleDownloadTypeEnum.AccessBlockedByRestriction,\n      )\n    } else if (entity && permissions?.canDownload) {\n      if (isFileEntity(entity) && entity.dataFileHandleId) {\n        setFileHandleDownloadType(FileHandleDownloadTypeEnum.Accessible)\n      } else {\n        setFileHandleDownloadType(FileHandleDownloadTypeEnum.NoFileHandle)\n      }\n    } else if (permissions && !permissions.canDownload) {\n      setFileHandleDownloadType(\n        accessToken\n          ? FileHandleDownloadTypeEnum.AccessBlockedByACL\n          : FileHandleDownloadTypeEnum.AccessBlockedToAnonymous,\n      )\n    }\n  }, [\n    accessToken,\n    entity,\n    entityFetchError,\n    permissions,\n    restrictionInformation,\n  ])\n\n  return fileHandleDownloadType\n}\n\n/**\n * HasAccess shows if the user has access to the file or not.\n *\n * The component's behavior changes whether it's passed in a FileHandle or not.\n * If passed a file handle then it will give more detailed information about the download.\n *\n * @export\n * @class HasAccess\n * @extends {React.Component<HasAccessProps, HasAccessState>}\n */\nexport function HasAccessV2(props: HasAccessProps) {\n  const [displayAccessRequirement, setDisplayAccessRequirement] =\n    React.useState(false)\n  const [accessRequirements, setAccessRequirements] = React.useState<\n    AccessRequirement[]\n  >([])\n\n  const { entityId, entityVersionNumber } = props\n\n  const fileHandleDownloadType = useGetFileHandleDownloadType(\n    entityId,\n    entityVersionNumber,\n  )\n\n  const { accessToken } = useSynapseContext()\n\n  const restrictionInformationRequest: RestrictionInformationRequest =\n    React.useMemo(\n      () => ({\n        restrictableObjectType: RestrictableObjectType.ENTITY,\n        objectId: entityId,\n      }),\n      [entityId],\n    )\n\n  const { data: restrictionInformation } = useGetRestrictionInformation(\n    restrictionInformationRequest,\n  )\n\n  const handleGetAccess = () => {\n    const { entityId } = props\n    // TODO: The fetch should really happen in the AR List component.\n    // If we need to open the AR page in synapse, the logic should be in the modal and it should just close itself right away\n    SynapseClient.getAllAccessRequirements(accessToken, entityId).then(\n      requirements => {\n        if (checkHasUnsportedRequirement(requirements)) {\n          window.open(\n            `${getEndpoint(\n              BackendDestinationEnum.PORTAL_ENDPOINT,\n            )}#!AccessRequirements:ID=${entityId}&TYPE=ENTITY`,\n            '_blank',\n          )\n        } else {\n          setAccessRequirements(requirements)\n          setDisplayAccessRequirement(true)\n        }\n      },\n    )\n  }\n\n  // Show Access Requirements\n  const AccessRequirements = () => {\n    const { entityId } = props\n    if (!restrictionInformation) {\n      // loading\n      return <></>\n    }\n    const hasUnmetAccessRequirement =\n      restrictionInformation?.hasUnmetAccessRequirement\n    const restrictionLevel = restrictionInformation?.restrictionLevel\n    let linkText = ''\n\n    if (hasUnmetAccessRequirement) {\n      linkText = 'Request Access'\n    } else if (RestrictionLevel.OPEN === restrictionLevel) {\n      // they need to sign in\n      return <></>\n    } else {\n      linkText = 'View Terms'\n    }\n    return (\n      <>\n        <a\n          style={{\n            fontSize: '14px',\n            cursor: 'pointer',\n            marginLeft: '5px',\n            verticalAlign: 'middle',\n          }}\n          className={props.className}\n          onClick={handleGetAccess}\n        >\n          {linkText}\n        </a>\n        {displayAccessRequirement && (\n          <AccessRequirementList\n            entityId={entityId}\n            accessRequirementFromProps={accessRequirements}\n            renderAsModal={true}\n            onHide={() => {\n              setDisplayAccessRequirement(false)\n            }}\n          />\n        )}\n      </>\n    )\n  }\n\n  if (fileHandleDownloadType === undefined) {\n    // note, this can't be \"if (!downloadType)\" since DownloadTypeEnum has a 0 value (which is falsy)\n    // loading\n    return <></>\n  }\n  const iconContainer =\n    fileHandleDownloadType ===\n    FileHandleDownloadTypeEnum.AccessBlockedToAnonymous ? (\n      <button\n        type=\"button\"\n        className={SRC_SIGN_IN_CLASS}\n        onClick={ev => {\n          if (ev.isTrusted) {\n            /*\n                There is a tricky problem - \n                The portals listens to click events for buttons with the class SRC_SIGN_IN_CLASS set, it listens to this event\n                so that it can display the login modal.\n\n                This button has an svg inside of it which is problematic because more often than not clicking this button will \n                instead click that svg. The event listener in the portals will break as a result.\n\n                Though the svg may get the actual click event, because of event bubbling this button will get its onClick called.\n                Once onClick is called we can manually dispatch an event off of this button. This does pose a problem, we end up in a \n                infinite loop because this button keeps disptaching click events, so we can use the isTrusted to recognize if onClick was\n                triggered programmatically or by user click. Lastly, using { bubbles: true } ensures the event bubbles up to the document level.\n\n              */\n            const clickEvent = new MouseEvent('click', { bubbles: true })\n            ev.currentTarget.dispatchEvent(clickEvent)\n          }\n        }}\n      >\n        <AccessIcon downloadType={fileHandleDownloadType} />\n      </button>\n    ) : (\n      <AccessIcon downloadType={fileHandleDownloadType} />\n    )\n\n  return (\n    <span style={{ whiteSpace: 'nowrap' }}>\n      {iconContainer}\n      <AccessRequirements />\n    </span>\n  )\n}\n"],"names":["warning","success","downloadType","_jsx","icon","tooltipText","_Fragment","accessToken","entityBundle","entityFetchError","ENTITY","entityId","restrictionInformation","React","setFileHandleDownloadType","entityVersionNumber","SynapseClient","window","setAccessRequirements","setDisplayAccessRequirement","linkText","_jsxs","className","handleGetAccess","accessRequirements","SRC_SIGN_IN_CLASS","ev","fileHandleDownloadType"],"mappings":"+fAGO,KAAM,GACX,4CAUW,EAAe,EAC1B,CACF,EChBA,EAAA,OAAA,MAwCA,EAAA,CAGI,AAAA,yBAAA,CACqD,KAAA,eAC/C,MAAA,AAAA,GAAA,EAAA,OAAA,QACuBA,YAAAA,uCAChB,EAHwC,AAAA,2BAAA,CAKE,KAAA,eACjD,MAAA,AAAA,GAAA,EAAA,OAAA,QACuBA,YAAAA,kDAChB,EAH0C,AAAA,mBAAA,CAKR,KAAA,eACzC,MAAA,AAAA,GAAA,EAAA,OAAA,QACuBA,YAAAA,gDAChB,EAHkC,AAAA,WAAA,CAMR,KAAA,aACjC,MAAA,AAAA,GAAA,EAAA,OAAA,QACuBC,YAAAA,EAChB,EAH0B,AAAA,aAAA,CAME,KAAA,aACnC,MAAA,AAAA,GAAA,EAAA,OAAA,QACuBA,YAAAA,EAChB,CA1Bb,EA8BJ,WAAA,EAAA,CACE,KAAA,CAAM,gBAAEC,EACR,GAAA,EAAA,CACE,KAAA,GAAA,EAAA,GACA,MAAAC,GAAA,EAAA,SAAA,CACE,SAAA,AAAA,GAAAA,EAAA,EAAA,CAEI,QAAA,CACW,KAAA,EAAA,KACaC,MAAAA,EAAAA,MAAAA,CAAAA,EACb,MAAA,EAAA,WACcC,CAHd,CAAA,CADX,CAAA,CAHN,CAeF,MAAAF,GAAAG,EAAA,CAAA,CAAA,CACD,CAUM,WAAA,EAAA,EAAA,CAIL,KAAA,CAAA,EAAA,GAAA,EAAA,SAAA,EAGA,CAAM,eAAEC,EAAAA,EACR,CAAM,KAAA,EAAQC,MAAAA,GAAqBC,EAAAA,EAAAA,CAEjC,cAAA,GACiB,mBAAA,EACK,EAAA,SAAA,UAAA,EAAA,CAAA,EAKxB,EAAA,EAAA,QAAA,IAAA,EAEW,uBAAA,EAAA,OAC0CC,SAAAA,CACrCC,GAAAA,CAAAA,CAAAA,CAAAA,EAKhB,CAAM,KAAA,GAAQC,EAAAA,CAAAA,EAId,EAAA,iBAAA,OACA,EAAA,iBAAA,YAEAC,SAAAA,UAAAA,IAAAA,CACE,AAAA,GAAA,EAAA,0BAIEC,EAAAA,4BAAAA,EAAyB,AAAA,GAAA,kBAAA,aAIzB,AAAA,EAAA,CAAA,GAAA,EAAA,iBACEA,EAAAA,YAAAA,EAEAA,EAAAA,cAAAA,EACD,GAAA,CAAA,EAAA,aAEDA,EAAAA,EAAAA,qBAAAA,2BAKD,EAAA,CAAA,EAAA,EAAA,EAAA,EAAA,CAAA,CAAA,EASH,CACD,CAYM,WAAA,EAAA,CACL,KAAA,CAAA,EAAA,GAAA,EAAA,SAAA,EAAA,EAEA,CAAA,EAAA,GAAA,EAAA,SAAA,CAAA,CAAA,EAIA,CAAM,WAAEH,uBAAUI,EAElB,EAAA,EAAA,EAAA,CAAA,EAKA,CAAM,eAAER,EAAAA,EAER,EAAA,EAAA,QAAA,IAAA,EAEW,uBAAA,EAAA,OAC0CG,SAAAA,CACrCC,GAAAA,CAAAA,CAAAA,CAAAA,EAKhB,CAAM,KAAA,GAAQC,EAAAA,CAAAA,EAId,EAAA,IAAA,CACE,KAAA,CAAM,SAAA,GAAED,EAGRK,EAAAA,EAAAA,CAAAA,EAAAA,KAAAA,AAAAA,GAAAA,CAEI,AAAA,EAAA,CAAA,EACEC,OAAAA,KAAAA,GAAAA,EAAAA,EAAAA,eAAAA,4BAAAA,gBAAAA,QAAAA,EAOAC,GAAAA,CAAAA,EACAC,EAAAA,EAAAA,EACD,CAAA,CAZL,EAkBF,EAAA,IAAA,CACE,KAAA,CAAM,SAAA,GAAER,EACR,GAAA,CAAA,EAEE,MAAAR,GAAAG,EAAA,CAAA,CAAA,EAEF,KAAA,GAAA,iBAAA,0BAEA,EAAA,iBAAA,iBACA,GAAA,GAAA,GAEA,GAAA,EACEc,EAAAA,qBAAW,IAAA,EAAA,OAAA,EAGX,MAAAjB,GAAAG,EAAA,CAAA,CAAA,EAEAc,EAAAA,aAEF,MAAAC,GAAAf,EAAA,CACE,SAAA,CAAAH,EAAA,IAAA,CACE,MAAA,CACS,SAAA,OACK,OAAA,UACF,WAAA,MACI,cAAA,QACG,EAJV,UAAA,EAAA,UAMUmB,QAAAA,EACRC,SAAAA,CAERH,CAAAA,EAAAA,GAAAA,EAAAA,EAAAA,CAGD,SAAA,EACYT,2BAAAA,EACkBa,cAAAA,GACb,OAAA,IAAA,CAEbL,EAAAA,EAAAA,CAA2B,CAC5B,CAAA,CAAA,CApBP,CAAA,CADF,EA4BF,MAAA,KAAA,OAGEhB,EAAAG,EAAA,CAAA,CAAA,EAmCFe,EAAA,OAAA,CACE,MAAA,CAAa,WAAA,QAAc,EAAd,SAAA,CAlCf,IAAA,2BAAAlB,EAAA,SAAA,CAGI,KAAA,SACO,UAAA,EACMsB,QAAAA,AAAAA,GAAAA,CAET,GAAA,EAAA,UAAA,CAeE,KAAA,GAAA,GAAA,YAAA,QAAA,CAA2C,QAAA,EAAW,CAAA,EACtDC,EAAAA,cAAAA,cAAAA,CAAAA,CAAA,CACD,EACF,SAAAvB,EAAA,EAAA,CAED,aAAA,CAA0BwB,CAAAA,CAA1B,CAAA,EAAAxB,EAAA,EAAA,CAGF,aAAA,CAA0BwB,CAAAA,EAIfxB,EAAA,EAAA,CAAA,CAAA,CAAA,CAAb,CAAA,CAKH;;;;;"}