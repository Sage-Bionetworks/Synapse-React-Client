{"version":3,"file":"queryUtils.f3f06d83.js","sources":["../../src/lib/utils/functions/queryUtils.ts"],"sourcesContent":["import {\n  QueryBundleRequest,\n  FacetColumnResult,\n  SelectColumn,\n} from '../synapseTypes/'\nimport { SynapseClient, SynapseConstants } from '..'\nimport { QueryResultBundle, FacetColumnResultValues } from '../synapseTypes/'\nimport { cloneDeep } from 'lodash-es'\n\ntype PartialStateObject = {\n  hasMoreData: boolean\n  data: QueryResultBundle\n}\n\n/**\n * Retrieve the index of a column using the column name\n * @param name the column name\n * @param result the QueryResultBundle containing the columns\n * @returns The index of the column, or -1 if the column doesn't exist in the result\n */\nexport const getFieldIndex = (\n  name: string,\n  result: QueryResultBundle | undefined,\n) => {\n  return (\n    result?.selectColumns?.findIndex(el => {\n      return el.name === name\n    }) ?? -1\n  )\n}\n\n/**\n * Grab the next page of data, pulling in 25 more rows.\n *\n * @param {*} queryRequest Query request as specified by\n *                         https://rest-docs.synapse.org/rest/org/sagebionetworks/repo/model/table/Query.html\n */\nexport const getNextPageOfData = async (\n  queryRequest: QueryBundleRequest,\n  data: QueryResultBundle,\n  token?: string,\n) => {\n  return await SynapseClient.getQueryTableResults(queryRequest, token)\n    .then((newData: QueryResultBundle) => {\n      const oldData: QueryResultBundle = cloneDeep(data)!\n      // push on the new data retrieved from the API call\n      const hasMoreData =\n        newData.queryResult!.queryResults.rows.length ===\n          queryRequest.query.limit ?? SynapseConstants.DEFAULT_PAGE_SIZE\n      oldData.queryResult!.queryResults.rows.push(\n        ...newData.queryResult!.queryResults.rows,\n      )\n      const newState: PartialStateObject = {\n        hasMoreData,\n        data: oldData,\n      }\n      return newState\n    })\n    .catch(err => {\n      console.log('Failed to get data ', err)\n      return {} as PartialStateObject\n    })\n}\n\nexport const isFacetAvailable = (\n  facets?: FacetColumnResult[],\n  selectColumns?: SelectColumn[],\n): boolean => {\n  /**\n   *  Facets are available iff\n   *    * there is at least one facet AND\n   *    * each facet has a corresponding columnModel in the selectColumns AND\n   *    * each facets has a valid value other than the null/not set value\n   */\n  if (facets == null || selectColumns == null) {\n    return false\n  }\n\n  if (facets.length === 0 || selectColumns.length === 0) {\n    return false\n  }\n\n  const facetsWithValuesAndColumnModels = facets.filter(facet => {\n    return (\n      !isSingleNotSetValue(facet) &&\n      selectColumns.find(model => model.name === facet.columnName)\n    )\n  })\n\n  return facetsWithValuesAndColumnModels.length > 0\n}\n\nexport const isSingleNotSetValue = (facet: FacetColumnResult): boolean => {\n  return (\n    facet.facetType === 'enumeration' &&\n    (facet as FacetColumnResultValues).facetValues.length == 1 &&\n    (facet as FacetColumnResultValues).facetValues[0].value ==\n      SynapseConstants.VALUE_NOT_SET\n  )\n}\n"],"names":["SynapseConstants.VALUE_NOT_SET"],"mappings":"wCAoBa,KAAA,GAAgB,CAC3B,EACA,IACG,SAED,MAAA,uBAAQ,gBAAR,cAAuB,UAAU,AAAM,GAC9B,EAAG,OAAS,KADrB,OAEM,EAEV,EAmCa,EAAmB,CAC9B,EACA,IAQI,GAAU,MAAQ,GAAiB,MAInC,EAAO,SAAW,GAAK,EAAc,SAAW,EAC3C,GAUF,AAPiC,EAAO,OAAO,AAAS,GAE3D,CAAC,EAAoB,CAAK,GAC1B,EAAc,KAAK,AAAS,GAAA,EAAM,OAAS,EAAM,UAAU,CAE9D,EAEsC,OAAS,EAGrC,EAAsB,AAAC,GAEhC,EAAM,YAAc,eACnB,EAAkC,YAAY,QAAU,GACxD,EAAkC,YAAY,GAAG,OAChDA"}