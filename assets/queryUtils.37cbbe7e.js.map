{"version":3,"file":"queryUtils.37cbbe7e.js","sources":["../../src/lib/utils/hooks/SynapseAPI/entity/useGetQueryResultBundle.ts","../../src/lib/utils/functions/queryUtils.ts"],"sourcesContent":["import { merge } from 'lodash-es'\nimport {\n  QueryFunctionContext,\n  QueryKey,\n  useInfiniteQuery,\n  UseInfiniteQueryOptions,\n  useQuery,\n  UseQueryOptions,\n} from 'react-query'\nimport { SynapseClient } from '../../..'\nimport { SynapseClientError } from '../../../SynapseClientError'\nimport {\n  BUNDLE_MASK_QUERY_RESULTS,\n  DEFAULT_PAGE_SIZE,\n} from '../../../SynapseConstants'\nimport { useSynapseContext } from '../../../SynapseContext'\nimport {\n  AsynchronousJobStatus,\n  QueryBundleRequest,\n  QueryResultBundle,\n} from '../../../synapseTypes'\nimport { entityQueryKeys } from './queryKeys'\n\nconst sharedQueryDefaults = {\n  refetchOnWindowFocus: false,\n}\n\n/**\n *\n * @param queryBundleRequest\n * @param options\n * @returns\n *\n * @deprecated - use useGetQueryResultBundleWithAsyncStatus. That hook can be renamed and this can be removed\n *  when all cases are using useGetQueryResultBundleWithAsyncStatus\n */\nexport default function useGetQueryResultBundle(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<QueryResultBundle, SynapseClientError>,\n) {\n  const { accessToken } = useSynapseContext()\n\n  return useQuery<QueryResultBundle, SynapseClientError>(\n    entityQueryKeys.tableQueryResult(queryBundleRequest, false),\n    () => SynapseClient.getQueryTableResults(queryBundleRequest, accessToken),\n    {\n      ...sharedQueryDefaults,\n      ...options,\n    },\n  )\n}\n\nfunction _useGetQueryResultBundleWithAsyncStatus(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  const { accessToken } = useSynapseContext()\n\n  return useQuery<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >(\n    entityQueryKeys.tableQueryResultWithAsyncStatus(queryBundleRequest, false),\n    () =>\n      SynapseClient.getQueryTableAsyncJobResults(\n        queryBundleRequest,\n        accessToken,\n        setCurrentAsyncStatus,\n      ),\n    {\n      ...sharedQueryDefaults,\n      ...options,\n    },\n  )\n}\n\nfunction useGetQueryRows(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  // Get the request for just the rows\n  const queryRowsBundleRequestMask =\n    queryBundleRequest.partMask & BUNDLE_MASK_QUERY_RESULTS\n  const rowsOnlyQueryBundleRequest: QueryBundleRequest = {\n    ...queryBundleRequest,\n    partMask: queryRowsBundleRequestMask,\n  }\n\n  const enableQuery = queryRowsBundleRequestMask > 0 ? options?.enabled : false\n\n  return _useGetQueryResultBundleWithAsyncStatus(\n    rowsOnlyQueryBundleRequest,\n    {\n      ...options,\n      enabled: enableQuery,\n    },\n    setCurrentAsyncStatus,\n  )\n}\n\nfunction useGetQueryStats(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  // Bitwise remove the query result flag from the mask\n  const queryStatsMask =\n    queryBundleRequest.partMask & ~BUNDLE_MASK_QUERY_RESULTS\n  const queryStatsRequest: QueryBundleRequest = {\n    ...queryBundleRequest,\n    query: {\n      ...queryBundleRequest.query,\n      // Remove query fields that don't affect the results.\n      offset: undefined,\n      limit: undefined,\n      sort: undefined,\n    },\n    partMask: queryStatsMask,\n  }\n\n  const enableQuery = queryStatsMask > 0 ? options?.enabled : false\n\n  return _useGetQueryResultBundleWithAsyncStatus(\n    queryStatsRequest,\n    {\n      ...options,\n      enabled: enableQuery,\n    },\n    setCurrentAsyncStatus,\n  )\n}\n\nexport function useGetQueryResultBundleWithAsyncStatus(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  /**\n   * Separate the query into two parts\n   *  - Query result rows, which will change each page\n   *  - Everything else, which does not change each page\n   */\n  const rowResult = useGetQueryRows(\n    queryBundleRequest,\n    options,\n    setCurrentAsyncStatus,\n  )\n  const statsResult = useGetQueryStats(\n    queryBundleRequest,\n    options,\n    setCurrentAsyncStatus,\n  )\n\n  // If either query is in error, return the error\n  if (rowResult.status === 'error') {\n    return rowResult\n  } else if (statsResult.status === 'error') {\n    return statsResult\n  } else if (rowResult.status === 'loading') {\n    // if either query is loading, return the loading status\n    return rowResult\n  } else if (statsResult.status === 'loading') {\n    return statsResult\n  } else {\n    // Otherwise, both queries are successful or idle, Merge the results into a single object\n    if (rowResult.status === 'idle') {\n      // If the row result is idle, apply the stats result last to override the idle status\n      return merge({}, rowResult, statsResult)\n    } else {\n      // Otherwise, always apply the rowResult last, since it is likely have been fetched more recently than the stats.\n      return merge({}, statsResult, rowResult)\n    }\n  }\n}\nexport function useInfiniteQueryResultBundle(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseInfiniteQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  const { accessToken } = useSynapseContext()\n  return useInfiniteQuery<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >(\n    entityQueryKeys.tableQueryResult(queryBundleRequest, true),\n    (context: QueryFunctionContext<QueryKey, string>) => {\n      const offset = context.pageParam ? parseInt(context.pageParam) : 0\n      return SynapseClient.getQueryTableAsyncJobResults(\n        {\n          ...queryBundleRequest,\n          query: {\n            ...queryBundleRequest.query,\n            offset: offset,\n          },\n          /**\n           * If we're on the first page, send the original partMask.\n           * Otherwise, just ask for the queryResults (if they're in the original partMask), as it's the only part that changes between pages.\n           *\n           * We'll merge the \"aggregation\" parts and the pages of queryResults in the `select` function.\n           */\n          partMask:\n            offset !== 0\n              ? queryBundleRequest.partMask & BUNDLE_MASK_QUERY_RESULTS\n              : queryBundleRequest.partMask,\n        },\n        accessToken,\n        setCurrentAsyncStatus,\n      )\n    },\n    {\n      ...sharedQueryDefaults,\n      ...options,\n      select: data => {\n        /**\n         * Since we we only fetch queryResults on 2nd and subsequent pages, we add to all pages the aggregate parts\n         * that we only fetched on the first page.\n         */\n        const firstPage = data?.pages[0]\n        if (firstPage.responseBody) {\n          for (let i = 0; i < data.pages.length; i++) {\n            const page = data.pages[i]\n            if (page.responseBody != null) {\n              data.pages[i].responseBody = {\n                ...firstPage.responseBody,\n                // queryResult changes on each page.\n                queryResult: page.responseBody.queryResult,\n              }\n            }\n          }\n        }\n        return data\n      },\n      getPreviousPageParam: firstPage => {\n        if (firstPage.jobState !== 'COMPLETE') {\n          return undefined\n        }\n        const request = firstPage.requestBody\n        if (request.query.offset == null || request.query.offset === 0) {\n          return undefined\n        }\n        const pageSize = request.query.limit ?? DEFAULT_PAGE_SIZE\n\n        return Math.max(request.query.offset - pageSize, 0)\n      },\n      getNextPageParam: (page, allPages) => {\n        if (page.jobState !== 'COMPLETE') {\n          return undefined\n        }\n        const request = page.requestBody\n        const pageSize = request.query.limit ?? DEFAULT_PAGE_SIZE\n        const totalQueryResultCount = allPages[0].responseBody?.queryCount\n        if (totalQueryResultCount != null) {\n          // We know the total number of results. See if our offset + pageSize is >= the total\n          if ((request.query.offset ?? 0) + pageSize >= totalQueryResultCount) {\n            return undefined\n          }\n        }\n        return page.responseBody!.queryResult?.queryResults.rows.length ===\n          pageSize\n          ? (request.query.offset ?? 0) + pageSize\n          : undefined\n      },\n    },\n  )\n}\n","import {\n  QueryBundleRequest,\n  FacetColumnResult,\n  SelectColumn,\n} from '../synapseTypes/'\nimport { SynapseClient, SynapseConstants } from '..'\nimport { QueryResultBundle, FacetColumnResultValues } from '../synapseTypes/'\nimport { cloneDeep } from 'lodash-es'\n\ntype PartialStateObject = {\n  hasMoreData: boolean\n  data: QueryResultBundle\n}\n\n/**\n * Retrieve the index of a column using the column name\n * @param name the column name\n * @param result the QueryResultBundle containing the columns\n * @returns The index of the column, or -1 if the column doesn't exist in the result\n */\nexport const getFieldIndex = (\n  name: string,\n  result: QueryResultBundle | undefined,\n) => {\n  return (\n    result?.selectColumns?.findIndex(el => {\n      return el.name === name\n    }) ?? -1\n  )\n}\n\n/**\n * Grab the next page of data, pulling in 25 more rows.\n *\n * @param {*} queryRequest Query request as specified by\n *                         https://rest-docs.synapse.org/rest/org/sagebionetworks/repo/model/table/Query.html\n */\nexport const getNextPageOfData = async (\n  queryRequest: QueryBundleRequest,\n  data: QueryResultBundle,\n  token?: string,\n) => {\n  return await SynapseClient.getQueryTableResults(queryRequest, token)\n    .then((newData: QueryResultBundle) => {\n      const oldData: QueryResultBundle = cloneDeep(data)!\n      // push on the new data retrieved from the API call\n      const hasMoreData =\n        newData.queryResult!.queryResults.rows.length ===\n          queryRequest.query.limit ?? SynapseConstants.DEFAULT_PAGE_SIZE\n      oldData.queryResult!.queryResults.rows.push(\n        ...newData.queryResult!.queryResults.rows,\n      )\n      const newState: PartialStateObject = {\n        hasMoreData,\n        data: oldData,\n      }\n      return newState\n    })\n    .catch(err => {\n      console.log('Failed to get data ', err)\n      return {} as PartialStateObject\n    })\n}\n\nexport const isFacetAvailable = (\n  facets?: FacetColumnResult[],\n  selectColumns?: SelectColumn[],\n): boolean => {\n  /**\n   *  Facets are available iff\n   *    * there is at least one facet AND\n   *    * each facet has a corresponding columnModel in the selectColumns AND\n   *    * each facets has a valid value other than the null/not set value\n   */\n  if (facets == null || selectColumns == null) {\n    return false\n  }\n\n  if (facets.length === 0 || selectColumns.length === 0) {\n    return false\n  }\n\n  const facetsWithValuesAndColumnModels = facets.filter(facet => {\n    return (\n      !isSingleNotSetValue(facet) &&\n      selectColumns.find(model => model.name === facet.columnName)\n    )\n  })\n\n  return facetsWithValuesAndColumnModels.length > 0\n}\n\nexport const isSingleNotSetValue = (facet: FacetColumnResult): boolean => {\n  return (\n    facet.facetType === 'enumeration' &&\n    (facet as FacetColumnResultValues).facetValues.length == 1 &&\n    (facet as FacetColumnResultValues).facetValues[0].value ==\n      SynapseConstants.VALUE_NOT_SET\n  )\n}\n"],"names":["SynapseClient.getQueryTableResults","SynapseClient.getQueryTableAsyncJobResults","SynapseConstants.VALUE_NOT_SET"],"mappings":"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"}