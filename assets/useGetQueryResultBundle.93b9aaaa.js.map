{"version":3,"file":"useGetQueryResultBundle.93b9aaaa.js","sources":["../../src/lib/utils/functions/queryUtils.ts","../../src/lib/utils/hooks/SynapseAPI/entity/useGetQueryResultBundle.ts"],"sourcesContent":["import {\n  QueryBundleRequest,\n  FacetColumnResult,\n  SelectColumn,\n} from '../synapseTypes/'\nimport { SynapseClient, SynapseConstants } from '..'\nimport { QueryResultBundle, FacetColumnResultValues } from '../synapseTypes/'\nimport { cloneDeep } from 'lodash-es'\n\ntype PartialStateObject = {\n  hasMoreData: boolean\n  data: QueryResultBundle\n}\n\n/**\n * Retrieve the index of a column using the column name\n * @param name the column name\n * @param result the QueryResultBundle containing the columns\n * @returns The index of the column, or -1 if the column doesn't exist in the result\n */\nexport const getFieldIndex = (\n  name: string,\n  result: QueryResultBundle | undefined,\n) => {\n  return (\n    result?.selectColumns?.findIndex(el => {\n      return el.name === name\n    }) ?? -1\n  )\n}\n\n/**\n * Grab the next page of data, pulling in 25 more rows.\n *\n * @param {*} queryRequest Query request as specified by\n *                         https://rest-docs.synapse.org/rest/org/sagebionetworks/repo/model/table/Query.html\n */\nexport const getNextPageOfData = async (\n  queryRequest: QueryBundleRequest,\n  data: QueryResultBundle,\n  token?: string,\n) => {\n  return await SynapseClient.getQueryTableResults(queryRequest, token)\n    .then((newData: QueryResultBundle) => {\n      const oldData: QueryResultBundle = cloneDeep(data)!\n      // push on the new data retrieved from the API call\n      const hasMoreData =\n        newData.queryResult.queryResults.rows.length ===\n          queryRequest.query.limit ?? SynapseConstants.DEFAULT_PAGE_SIZE\n      oldData.queryResult.queryResults.rows.push(\n        ...newData.queryResult.queryResults.rows,\n      )\n      const newState: PartialStateObject = {\n        hasMoreData,\n        data: oldData,\n      }\n      return newState\n    })\n    .catch(err => {\n      console.log('Failed to get data ', err)\n      return {} as PartialStateObject\n    })\n}\n\nexport const isFacetAvailable = (\n  facets?: FacetColumnResult[],\n  selectColumns?: SelectColumn[],\n): boolean => {\n  /**\n   *  Facets are available iff\n   *    * there is at least one facet AND\n   *    * each facet has a corresponding columnModel in the selectColumns AND\n   *    * each facets has a valid value other than the null/not set value\n   */\n  if (facets == null || selectColumns == null) {\n    return false\n  }\n\n  if (facets.length === 0 || selectColumns.length === 0) {\n    return false\n  }\n\n  const facetsWithValuesAndColumnModels = facets.filter(facet => {\n    return (\n      !isSingleNotSetValue(facet) &&\n      selectColumns.find(model => model.name === facet.columnName)\n    )\n  })\n\n  return facetsWithValuesAndColumnModels.length > 0\n}\n\nexport const isSingleNotSetValue = (facet: FacetColumnResult): boolean => {\n  return (\n    facet.facetType === 'enumeration' &&\n    (facet as FacetColumnResultValues).facetValues.length == 1 &&\n    (facet as FacetColumnResultValues).facetValues[0].value ==\n      SynapseConstants.VALUE_NOT_SET\n  )\n}\n","import {\n  QueryFunctionContext,\n  QueryKey,\n  useInfiniteQuery,\n  UseInfiniteQueryOptions,\n  useQuery,\n  UseQueryOptions,\n} from 'react-query'\nimport { SynapseClient } from '../../..'\nimport { SynapseClientError } from '../../../SynapseClient'\nimport {\n  BUNDLE_MASK_QUERY_RESULTS,\n  DEFAULT_PAGE_SIZE,\n} from '../../../SynapseConstants'\nimport { useSynapseContext } from '../../../SynapseContext'\nimport {\n  AsynchronousJobStatus,\n  QueryBundleRequest,\n  QueryResultBundle,\n} from '../../../synapseTypes'\nimport { entityQueryKeys } from './queryKeys'\n\nconst sharedQueryDefaults = {\n  refetchOnWindowFocus: false,\n}\n\n/**\n *\n * @param queryBundleRequest\n * @param options\n * @returns\n *\n * @deprecated - use useGetQueryResultBundleWithAsyncStatus. That hook can be renamed and this can be removed\n *  when all cases are using useGetQueryResultBundleWithAsyncStatus\n */\nexport default function useGetQueryResultBundle(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<QueryResultBundle, SynapseClientError>,\n) {\n  const { accessToken } = useSynapseContext()\n\n  return useQuery<QueryResultBundle, SynapseClientError>(\n    entityQueryKeys.tableQueryResult(queryBundleRequest, false),\n    () => SynapseClient.getQueryTableResults(queryBundleRequest, accessToken),\n    {\n      ...sharedQueryDefaults,\n      ...options,\n    },\n  )\n}\n\nexport function useGetQueryResultBundleWithAsyncStatus(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  const { accessToken } = useSynapseContext()\n\n  return useQuery<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >(\n    entityQueryKeys.tableQueryResultWithAsyncStatus(queryBundleRequest, false),\n    () =>\n      SynapseClient.getQueryTableAsyncJobResults(\n        queryBundleRequest,\n        accessToken,\n        setCurrentAsyncStatus,\n      ),\n    {\n      ...sharedQueryDefaults,\n      ...options,\n    },\n  )\n}\nexport function useInfiniteQueryResultBundle(\n  queryBundleRequest: QueryBundleRequest,\n  options?: UseInfiniteQueryOptions<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >,\n  setCurrentAsyncStatus?: (\n    status: AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n  ) => void,\n) {\n  const { accessToken } = useSynapseContext()\n  return useInfiniteQuery<\n    AsynchronousJobStatus<QueryBundleRequest, QueryResultBundle>,\n    SynapseClientError\n  >(\n    entityQueryKeys.tableQueryResult(queryBundleRequest, true),\n    (context: QueryFunctionContext<QueryKey, string>) => {\n      const offset = context.pageParam ? parseInt(context.pageParam) : 0\n      return SynapseClient.getQueryTableAsyncJobResults(\n        {\n          ...queryBundleRequest,\n          query: {\n            ...queryBundleRequest.query,\n            offset: offset,\n          },\n          /**\n           * If we're on the first page, send the original partMask.\n           * Otherwise, just ask for the queryResults (if they're in the original partMask), as it's the only part that changes between pages.\n           *\n           * We'll merge the \"aggregation\" parts and the pages of queryResults in the `select` function.\n           */\n          partMask:\n            offset !== 0\n              ? queryBundleRequest.partMask & BUNDLE_MASK_QUERY_RESULTS\n              : queryBundleRequest.partMask,\n        },\n        accessToken,\n        setCurrentAsyncStatus,\n      )\n    },\n    {\n      ...sharedQueryDefaults,\n      ...options,\n      select: data => {\n        /**\n         * Since we we only fetch queryResults on 2nd and subsequent pages, we add to all pages the aggregate parts\n         * that we only fetched on the first page.\n         */\n        const firstPage = data?.pages[0]\n        if (firstPage.responseBody) {\n          for (let i = 0; i < data.pages.length; i++) {\n            const page = data.pages[i]\n            if (page.responseBody != null) {\n              data.pages[i].responseBody = {\n                ...firstPage.responseBody,\n                // queryResult changes on each page.\n                queryResult: page.responseBody.queryResult,\n              }\n            }\n          }\n        }\n        return data\n      },\n      getPreviousPageParam: firstPage => {\n        if (firstPage.jobState !== 'COMPLETE') {\n          return undefined\n        }\n        const request = firstPage.requestBody\n        if (request.query.offset == null || request.query.offset === 0) {\n          return undefined\n        }\n        const pageSize = request.query.limit ?? DEFAULT_PAGE_SIZE\n\n        return Math.max(request.query.offset - pageSize, 0)\n      },\n      getNextPageParam: (page, allPages) => {\n        if (page.jobState !== 'COMPLETE') {\n          return undefined\n        }\n        const request = page.requestBody\n        const pageSize = request.query.limit ?? DEFAULT_PAGE_SIZE\n        const totalQueryResultCount = allPages[0].responseBody?.queryCount\n        if (totalQueryResultCount != null) {\n          // We know the total number of results. See if our offset + pageSize is >= the total\n          if ((request.query.offset ?? 0) + pageSize >= totalQueryResultCount) {\n            return undefined\n          }\n        }\n        return page.responseBody!.queryResult.queryResults.rows.length ===\n          pageSize\n          ? (request.query.offset ?? 0) + pageSize\n          : undefined\n      },\n    },\n  )\n}\n"],"names":["SynapseConstants.VALUE_NOT_SET","SynapseClient.getQueryTableResults","SynapseClient.getQueryTableAsyncJobResults"],"mappings":"0NAoBa,KAAA,GAAgB,CAC3B,EACA,IACG,SAED,MAAA,uBAAQ,gBAAR,cAAuB,UAAU,AAAM,GAC9B,EAAG,OAAS,KADrB,OAEM,EAEV,EAmCa,EAAmB,CAC9B,EACA,IAQI,GAAU,MAAQ,GAAiB,MAInC,EAAO,SAAW,GAAK,EAAc,SAAW,EAC3C,GAUF,AAPiC,EAAO,OAAO,AAAS,GAE3D,CAAC,EAAoB,CAAK,GAC1B,EAAc,KAAK,AAAS,GAAA,EAAM,OAAS,EAAM,UAAU,CAE9D,EAEsC,OAAS,EAGrC,EAAsB,AAAC,GAEhC,EAAM,YAAc,eACnB,EAAkC,YAAY,QAAU,GACxD,EAAkC,YAAY,GAAG,OAChDA,EC3EA,EAAsB,CAC1B,qBAAsB,EACxB,EAWA,WACE,EACA,EACA,CACM,KAAA,CAAE,eAAgB,IAEjB,MAAA,GACL,EAAgB,iBAAiB,EAAoB,EAAK,EAC1D,IAAMC,EAAmC,EAAoB,CAAW,EACxE,CACE,GAAG,EACH,GAAG,CAAA,CAEP,CACF,CAGE,WAAA,EACA,EAIA,EAGA,CACM,KAAA,CAAE,eAAgB,IAExB,MAAO,GAIL,EAAgB,gCAAgC,EAAoB,EAAK,EACzE,IACEC,EACE,EACA,EACA,CACF,EACF,CACE,GAAG,EACH,GAAG,CAAA,CAEP,CACF,CAEE,WAAA,EACA,EAIA,EAGA,CACM,KAAA,CAAE,eAAgB,IACxB,MAAO,GAIL,EAAgB,iBAAiB,EAAoB,EAAI,EACzD,AAAC,GAAoD,CACnD,KAAM,GAAS,EAAQ,UAAY,SAAS,EAAQ,SAAS,EAAI,EACjE,MAAOA,GACL,CACE,GAAG,EACH,MAAO,CACL,GAAG,EAAmB,MACtB,QACF,EAOA,SACE,IAAW,EACP,EAAmB,SAAW,EAC9B,EAAmB,QAAA,EAE3B,EACA,CACF,CAAA,EAEF,CACE,GAAG,EACH,GAAG,EACH,OAAQ,AAAQ,GAAA,CAKR,KAAA,GAAY,iBAAM,MAAM,GAC9B,GAAI,EAAU,aACZ,OAAS,GAAI,EAAG,EAAI,EAAK,MAAM,OAAQ,IAAK,CACpC,KAAA,GAAO,EAAK,MAAM,GACpB,AAAA,EAAK,cAAgB,MAClB,GAAA,MAAM,GAAG,aAAe,CAC3B,GAAG,EAAU,aAEb,YAAa,EAAK,aAAa,WAAA,EAGrC,CAEK,MAAA,EACT,EACA,qBAAsB,AAAa,GAAA,OAC7B,GAAA,EAAU,WAAa,WAClB,OAET,KAAM,GAAU,EAAU,YAC1B,GAAI,EAAQ,MAAM,QAAU,MAAQ,EAAQ,MAAM,SAAW,EACpD,OAEH,KAAA,GAAW,KAAQ,MAAM,QAAd,OAAuB,EAExC,MAAO,MAAK,IAAI,EAAQ,MAAM,OAAS,EAAU,CAAC,CACpD,EACA,iBAAkB,CAAC,EAAM,IAAa,aAChC,GAAA,EAAK,WAAa,WACb,OAET,KAAM,GAAU,EAAK,YACf,EAAW,KAAQ,MAAM,QAAd,OAAuB,EAClC,EAAwB,KAAS,GAAG,eAAZ,cAA0B,WACxD,GAAI,KAAyB,MAEd,MAAA,MAAM,SAAN,OAAgB,GAAK,GAAY,GAIzC,MAAA,GAAK,aAAc,YAAY,aAAa,KAAK,SACtD,EACW,MAAA,MAAM,SAAN,OAAgB,GAAK,EAC9B,MACN,CAAA,CAEJ,CACF"}