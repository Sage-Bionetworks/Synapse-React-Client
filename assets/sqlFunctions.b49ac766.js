const A=/^10.\d{4,9}\/[-._;()\/:a-z0-9]+$/i,f=/^(syn\d+)(?:\.(\d+))?$/,R=window.SQLParser.lexer,O=window.SQLParser.parser,p=/group by/im,S=e=>p.test(e),x=3,T=(e,t,n)=>{let s=n;n.match(f)&&(s=n.substring(x));const i=n.split(",").map(r=>`'${r}'`).join(",");switch(t){case"LIKE":return[["LITERAL",e,"1"],["OPERATOR",t,"1"],["STRING",`%${s}%`,"1"]];case"HAS":return[["LITERAL",e,"1"],["OPERATOR",t,"1"],["PARAMETER",`(${i})`,"1"]];default:return[["LITERAL",e,"1"],["OPERATOR",t,"1"],["STRING",n,"1"]]}},L=e=>{const t=e.findIndex(s=>s[0]==="WHERE");if(t!==-1)return t;let n=e.findIndex(s=>s[0]==="GROUP");return n!==-1||(n=e.findIndex(s=>s[0]==="HAVING"),n!==-1)||(n=e.findIndex(s=>s[0]==="ORDER"),n!==-1)||(n=e.findIndex(s=>s[0]==="EOF")),n},l=(e,t,n="LIKE")=>{if(!t)return e;const s=d=>d.startsWith("QueryWrapper"),i=Object.keys(t);if(i.length===0||i.every(s))return e;const r=R.tokenize(e),c=r.findIndex(d=>d[0]==="WHERE"),o=L(r),I=o+1;c===-1?r.splice(o,0,["WHERE","WHERE","1"]):r.splice(I,0,["CONDITIONAL","AND","1"]);const E=Object.keys(t).length;return Object.keys(t).forEach((d,u)=>{const a=T(d,n,t[d]);u<E-1&&a.unshift(["CONDITIONAL","AND","1"]),r.splice(I,0,...a)}),y(r)},y=e=>{e.forEach(r=>{r[0]==="DBLSTRING"&&(r[0]="LITERAL")});const t=e.findIndex(r=>r[0]==="DOT");if(t!==-1){const r=e[t-1][1],c=e[t+1][1],o=`${r}.${c}`;e.splice(t,2),e[t-1]=["LITERAL",o]}const n=O.parse(e).toString(),s=e[e.findIndex(r=>r[0]==="FROM")+1][1],i=`\`${s}\``;return n.replace(i,s)},h=e=>{const t=e.match(/(from)\s+(syn)\d+/gi);return t&&t[0]?t[0].substr(5).trim():""},m=e=>{const n=/from\s+(syn\d+)(?:\.(\d+))?/i.exec(e);return n?{entityId:n[1],versionNumber:n[2]?parseInt(n[2]):void 0}:null},N=(e,t)=>{const n=[],s=t.map(r=>r.values),i=e.map(r=>r.name);return s.forEach((r,c)=>{n[c]={},r.forEach((o,I)=>{n[c][i[I]]=o})}),n};export{A as D,f as S,m as a,S as b,y as f,l as i,h as p,N as r};
